<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>37.2. Database Access from PL/Perl</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
<link rel="start" href="index.html" title="PostgreSQL 8.0.12 Documentation">
<link rel="up" href="plperl.html" title="Chapter 37. PL/Perl - Perl Procedural Language">
<link rel="prev" href="plperl.html" title="Chapter 37. PL/Perl - Perl Procedural Language">
<link rel="next" href="plperl-data.html" title="37.3. Data Values in PL/Perl">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="plperl-database"></a>37.2. Database Access from PL/Perl</h2></div></div></div>
<p>   Access to the database itself from your Perl function can be done
   via the function <code class="function">spi_exec_query</code> described
   below, or via an experimental module <a href="http://www.cpan.org/modules/by-module/DBD/APILOS/" target="_top"><code class="literal">DBD::PgSPI</code></a>
   (also available at <a href="http://www.cpan.org/SITES.html" target="_top"><acronym class="acronym">CPAN</acronym> mirror
   sites</a>).  This module makes available a
   <acronym class="acronym">DBI</acronym>-compliant database-handle named
   <code class="varname">$pg_dbh</code> that can be used to perform queries with
   normal <acronym class="acronym">DBI</acronym>
   syntax.<a name="id2702495"></a>
  </p>
<p>   PL/Perl itself presently provides two additional Perl commands:

   </p>
<div class="variablelist"><dl>
<dt>
<span xmlns="http://www.w3.org/TR/xhtml1/transitional" class="term"><code xmlns="" class="literal"><code class="function">spi_exec_query</code>(<em class="replaceable"><code>query</code></em> [, <em class="replaceable"><code>max-rows</code></em>])</code></span><br xmlns="http://www.w3.org/TR/xhtml1/transitional"></br><span class="term"><code class="literal"><code class="function">spi_exec_query</code>(<em class="replaceable"><code>command</code></em>)</code></span>
</dt>
<dd>
<p>       Executes an SQL command.  Here is an example of a query
       (<code class="command">SELECT</code> command) with the optional maximum
       number of rows:
</p>
<pre class="programlisting">$rv = spi_exec_query('SELECT * FROM my_table', 5);</pre>
<p>
        This returns up to 5 rows from the table
        <code class="literal">my_table</code>.  If <code class="literal">my_table</code>
        has a column <code class="literal">my_column</code>, you can get that
        value from row <code class="literal">$i</code> of the result like this:
</p>
<pre class="programlisting">$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};</pre>
<p>
       The total number of rows returned from a <code class="command">SELECT</code>
       query can be accessed like this:
</p>
<pre class="programlisting">$nrows = $rv-&gt;{processed}</pre>
<p>
      </p>
<p>       Here is an example using a different command type:
</p>
<pre class="programlisting">$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);</pre>
<p>
       You can then access the command status (e.g.,
       <code class="literal">SPI_OK_INSERT</code>) like this:
</p>
<pre class="programlisting">$res = $rv-&gt;{status};</pre>
<p>
       To get the number of rows affected, do:
</p>
<pre class="programlisting">$nrows = $rv-&gt;{processed};</pre>
<p>
      </p>
<p>       Here is a complete example:
</p>
<pre class="programlisting">CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $res = [];
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        push @$res, $row;
    }
    return $res;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();</pre>
<p>
      </p>
</dd>
<dt><span class="term"><code class="literal"><code class="function">elog</code>(<em class="replaceable"><code>level</code></em>, <em class="replaceable"><code>msg</code></em>)</code></span></dt>
<dd><p>       Emit a log or error message. Possible levels are
       <code class="literal">DEBUG</code>, <code class="literal">LOG</code>, <code class="literal">INFO</code>,
       <code class="literal">NOTICE</code>, <code class="literal">WARNING</code>, and <code class="literal">ERROR</code>.
       <code class="literal">ERROR</code>
        raises an error condition; if this is not trapped by the surrounding
        Perl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Perl <code class="literal">die</code> command.
        The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <a href="runtime-config.html#guc-log-min-messages">log_min_messages</a> and
        <a href="runtime-config.html#guc-client-min-messages">client_min_messages</a> configuration
        variables. See <a href="runtime-config.html" title="16.4. Run-time Configuration">Section 16.4, &#8220;Run-time Configuration&#8221;</a> for more
        information.
      </p></dd>
</dl></div>
<p>
  </p>
</div></body>
</html>
