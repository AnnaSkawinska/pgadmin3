<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Value Expressions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL Syntax"
HREF="sql-syntax.html"><LINK
REL="PREVIOUS"
TITLE="SQL Syntax"
HREF="sql-syntax.html"><LINK
REL="NEXT"
TITLE="Data Definition"
HREF="ddl.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-10-03T03:19:47"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 4. SQL Syntax</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-syntax.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="ddl.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SQL-EXPRESSIONS"
>4.2. Value Expressions</A
></H1
><A
NAME="AEN1479"
></A
><A
NAME="AEN1482"
></A
><A
NAME="AEN1484"
></A
><P
>   Value expressions are used in a variety of contexts, such
   as in the target list of the <TT
CLASS="COMMAND"
>SELECT</TT
> command, as
   new column values in <TT
CLASS="COMMAND"
>INSERT</TT
> or
   <TT
CLASS="COMMAND"
>UPDATE</TT
>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <I
CLASS="FIRSTTERM"
>scalar</I
>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <I
CLASS="FIRSTTERM"
>scalar expressions</I
> (or
   even simply <I
CLASS="FIRSTTERM"
>expressions</I
>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
  </P
><P
>   A value expression is one of the following:

   <P
></P
></P><UL
><LI
><P
>      A constant or literal value; see <A
HREF="sql-syntax.html#SQL-SYNTAX-CONSTANTS"
>Section 4.1.2</A
>.
     </P
></LI
><LI
><P
>      A column reference.
     </P
></LI
><LI
><P
>      A positional parameter reference, in the body of a function definition
      or prepared statement.
     </P
></LI
><LI
><P
>      An operator invocation.
     </P
></LI
><LI
><P
>      A function call.
     </P
></LI
><LI
><P
>      An aggregate expression.
     </P
></LI
><LI
><P
>      A type cast.
     </P
></LI
><LI
><P
>      A scalar subquery.
     </P
></LI
><LI
><P
>      An array constructor.
     </P
></LI
><LI
><P
>      Another value expression in parentheses, useful to group
      subexpressions and override
      precedence.<A
NAME="AEN1517"
></A
>
     </P
></LI
></UL
><P>
  </P
><P
>   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <A
HREF="functions.html"
>Chapter 9</A
>.  An example is the <VAR
CLASS="LITERAL"
>IS NULL</VAR
>
   clause.
  </P
><P
>   We have already discussed constants in <A
HREF="sql-syntax.html#SQL-SYNTAX-CONSTANTS"
>Section 4.1.2</A
>.  The following sections discuss
   the remaining options.
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1524"
>4.2.1. Column References</A
></H2
><A
NAME="AEN1526"
></A
><P
>    A column can be referenced in the form
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>correlation</VAR
>.<VAR
CLASS="REPLACEABLE"
>columnname</VAR
></PRE
><P>
    or
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>correlation</VAR
>.<VAR
CLASS="REPLACEABLE"
>columnname</VAR
>[<VAR
CLASS="REPLACEABLE"
>subscript</VAR
>]</PRE
><P>
    (Here, the brackets <VAR
CLASS="LITERAL"
>[ ]</VAR
> are meant to appear literally.)
   </P
><P
>    <VAR
CLASS="REPLACEABLE"
>correlation</VAR
> is the name of a
    table (possibly qualified), or an alias for a table defined by means of a
    <VAR
CLASS="LITERAL"
>FROM</VAR
> clause, or 
    the key words <VAR
CLASS="LITERAL"
>NEW</VAR
> or <VAR
CLASS="LITERAL"
>OLD</VAR
>.
    (<VAR
CLASS="LITERAL"
>NEW</VAR
> and <VAR
CLASS="LITERAL"
>OLD</VAR
> can only appear in rewrite rules,
    while other correlation names can be used in any SQL statement.)
    The correlation name and separating dot may be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <A
HREF="queries.html"
>Chapter 7</A
>.)
   </P
><P
>    If <VAR
CLASS="REPLACEABLE"
>column</VAR
> is of an array type, then the
    optional <VAR
CLASS="REPLACEABLE"
>subscript</VAR
> selects a specific
    element or elements in the array.  If no subscript is provided, then the
    whole array is selected.  (See <A
HREF="arrays.html"
>Section 8.10</A
> for more about
    arrays.)
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1549"
>4.2.2. Positional Parameters</A
></H2
><A
NAME="AEN1551"
></A
><A
NAME="AEN1554"
></A
><P
>    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
</P><PRE
CLASS="SYNOPSIS"
>$<VAR
CLASS="REPLACEABLE"
>number</VAR
></PRE
><P>
   </P
><P
>    For example, consider the definition of a function,
    <CODE
CLASS="FUNCTION"
>dept</CODE
>, as

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION dept(text) RETURNS dept
    AS 'SELECT * FROM dept WHERE name = $1'
    LANGUAGE SQL;</PRE
><P>

    Here the <VAR
CLASS="LITERAL"
>$1</VAR
> will be replaced by the first
    function argument when the function is invoked.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1563"
>4.2.3. Operator Invocations</A
></H2
><A
NAME="AEN1565"
></A
><P
>    There are three possible syntaxes for an operator invocation:
    <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><VAR
CLASS="REPLACEABLE"
>expression</VAR
> <VAR
CLASS="REPLACEABLE"
>operator</VAR
> <VAR
CLASS="REPLACEABLE"
>expression</VAR
> (binary infix operator)</TD
></TR
><TR
><TD
><VAR
CLASS="REPLACEABLE"
>operator</VAR
> <VAR
CLASS="REPLACEABLE"
>expression</VAR
> (unary prefix operator)</TD
></TR
><TR
><TD
><VAR
CLASS="REPLACEABLE"
>expression</VAR
> <VAR
CLASS="REPLACEABLE"
>operator</VAR
> (unary postfix operator)</TD
></TR
></TBODY
></TABLE
><P
></P
>
    where the <VAR
CLASS="REPLACEABLE"
>operator</VAR
> token follows the syntax
    rules of <A
HREF="sql-syntax.html#SQL-SYNTAX-OPERATORS"
>Section 4.1.3</A
>, or is one of the
    keywords <TT
CLASS="TOKEN"
>AND</TT
>, <TT
CLASS="TOKEN"
>OR</TT
>, and
    <TT
CLASS="TOKEN"
>NOT</TT
>, or is a qualified operator name
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="LITERAL"
>OPERATOR(</VAR
><VAR
CLASS="REPLACEABLE"
>schema</VAR
><VAR
CLASS="LITERAL"
>.</VAR
><VAR
CLASS="REPLACEABLE"
>operatorname</VAR
><VAR
CLASS="LITERAL"
>)</VAR
></PRE
><P>
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <A
HREF="functions.html"
>Chapter 9</A
>
    describes the built-in operators.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1592"
>4.2.4. Function Calls</A
></H2
><A
NAME="AEN1594"
></A
><P
>    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:

</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>function</VAR
> ([<SPAN
CLASS="OPTIONAL"
><VAR
CLASS="REPLACEABLE"
>expression</VAR
> [<SPAN
CLASS="OPTIONAL"
>, <VAR
CLASS="REPLACEABLE"
>expression</VAR
> ... </SPAN
>]</SPAN
>] )</PRE
><P>
   </P
><P
>    For example, the following computes the square root of 2:
</P><PRE
CLASS="PROGRAMLISTING"
>sqrt(2)</PRE
><P>
   </P
><P
>    The list of built-in functions is in <A
HREF="functions.html"
>Chapter 9</A
>.
    Other functions may be added by the user.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYNTAX-AGGREGATES"
>4.2.5. Aggregate Expressions</A
></H2
><A
NAME="AEN1610"
></A
><P
>    An <I
CLASS="FIRSTTERM"
>aggregate expression</I
> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:

</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>aggregate_name</VAR
> (<VAR
CLASS="REPLACEABLE"
>expression</VAR
>)
<VAR
CLASS="REPLACEABLE"
>aggregate_name</VAR
> (ALL <VAR
CLASS="REPLACEABLE"
>expression</VAR
>)
<VAR
CLASS="REPLACEABLE"
>aggregate_name</VAR
> (DISTINCT <VAR
CLASS="REPLACEABLE"
>expression</VAR
>)
<VAR
CLASS="REPLACEABLE"
>aggregate_name</VAR
> ( * )</PRE
><P>

    where <VAR
CLASS="REPLACEABLE"
>aggregate_name</VAR
> is a previously
    defined aggregate (possibly a qualified name), and
    <VAR
CLASS="REPLACEABLE"
>expression</VAR
> is 
    any value expression that does not itself contain an aggregate
    expression.
   </P
><P
>    The first form of aggregate expression invokes the aggregate
    across all input rows for which the given expression yields a
    non-null value.  (Actually, it is up to the aggregate function
    whether to ignore null values or not --- but all the standard ones do.)
    The second form is the same as the first, since
    <VAR
CLASS="LITERAL"
>ALL</VAR
> is the default.  The third form invokes the
    aggregate for all distinct non-null values of the expression found
    in the input rows.  The last form invokes the aggregate once for
    each input row regardless of null or non-null values; since no
    particular input value is specified, it is generally only useful
    for the <CODE
CLASS="FUNCTION"
>count()</CODE
> aggregate function.
   </P
><P
>    For example, <VAR
CLASS="LITERAL"
>count(*)</VAR
> yields the total number
    of input rows; <VAR
CLASS="LITERAL"
>count(f1)</VAR
> yields the number of
    input rows in which <VAR
CLASS="LITERAL"
>f1</VAR
> is non-null;
    <VAR
CLASS="LITERAL"
>count(distinct f1)</VAR
> yields the number of
    distinct non-null values of <VAR
CLASS="LITERAL"
>f1</VAR
>.
   </P
><P
>    The predefined aggregate functions are described in <A
HREF="functions-aggregate.html"
>Section 9.15</A
>.  Other aggregate functions may be added
    by the user. 
   </P
><P
>    An aggregate expression may only appear in the result list or
    <VAR
CLASS="LITERAL"
>HAVING</VAR
> clause of a <TT
CLASS="COMMAND"
>SELECT</TT
> command.
    It is forbidden in other clauses, such as <VAR
CLASS="LITERAL"
>WHERE</VAR
>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
   </P
><P
>    When an aggregate expression appears in a subquery (see
    <A
HREF="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES"
>Section 4.2.7</A
> and
    <A
HREF="functions-subquery.html"
>Section 9.16</A
>), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's argument contains only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <VAR
CLASS="LITERAL"
>HAVING</VAR
> clause
    applies with respect to the query level that the aggregate belongs to.
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-TYPE-CASTS"
>4.2.6. Type Casts</A
></H2
><A
NAME="AEN1646"
></A
><A
NAME="AEN1649"
></A
><P
>    A type cast specifies a conversion from one data type to another.
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> accepts two equivalent syntaxes
    for type casts:
</P><PRE
CLASS="SYNOPSIS"
>CAST ( <VAR
CLASS="REPLACEABLE"
>expression</VAR
> AS <VAR
CLASS="REPLACEABLE"
>type</VAR
> )
<VAR
CLASS="REPLACEABLE"
>expression</VAR
>::<VAR
CLASS="REPLACEABLE"
>type</VAR
></PRE
><P>
    The <VAR
CLASS="LITERAL"
>CAST</VAR
> syntax conforms to SQL; the syntax with
    <VAR
CLASS="LITERAL"
>::</VAR
> is historical <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
    usage.
   </P
><P
>    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion function is available.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <A
HREF="sql-syntax.html#SQL-SYNTAX-CONSTANTS-GENERIC"
>Section 4.1.2.4</A
>.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
   </P
><P
>    An explicit type cast may usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <SPAN
CLASS="QUOTE"
>"OK to apply implicitly"</SPAN
>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
   </P
><P
>    It is also possible to specify a type cast using a function-like
    syntax:
</P><PRE
CLASS="SYNOPSIS"
><VAR
CLASS="REPLACEABLE"
>typename</VAR
> ( <VAR
CLASS="REPLACEABLE"
>expression</VAR
> )</PRE
><P>
    However, this only works for types whose names are also valid as
    function names.  For example, <VAR
CLASS="LITERAL"
>double precision</VAR
>
    can't be used this way, but the equivalent <VAR
CLASS="LITERAL"
>float8</VAR
>
    can.  Also, the names <VAR
CLASS="LITERAL"
>interval</VAR
>, <VAR
CLASS="LITERAL"
>time</VAR
>, and
    <VAR
CLASS="LITERAL"
>timestamp</VAR
> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided in new applications.

    (The function-like syntax is in fact just a function call.  When
    one of the two standard cast syntaxes is used to do a run-time
    conversion, it will internally invoke a registered function to
    perform the conversion.  By convention, these conversion functions
    have the same name as their output type, and thus the <SPAN
CLASS="QUOTE"
>"function-like
    syntax"</SPAN
> is nothing more than a direct invocation of the underlying
    conversion function.  Obviously, this is not something that a portable
    application should rely on.)
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-SCALAR-SUBQUERIES"
>4.2.7. Scalar Subqueries</A
></H2
><A
NAME="AEN1677"
></A
><P
>    A scalar subquery is an ordinary
    <TT
CLASS="COMMAND"
>SELECT</TT
> query in parentheses that returns exactly one
    row with one column.  (See <A
HREF="queries.html"
>Chapter 7</A
> for information about writing queries.)
    The <TT
CLASS="COMMAND"
>SELECT</TT
> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <A
HREF="functions-subquery.html"
>Section 9.16</A
>.
   </P
><P
>    For example, the following finds the largest city population in each
    state:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-ARRAY-CONSTRUCTORS"
>4.2.8. Array Constructors</A
></H2
><A
NAME="AEN1688"
></A
><P
>    An <I
CLASS="FIRSTTERM"
>array constructor</I
> is an expression that builds an
    array value from values for its member elements.  A simple array
    constructor 
    consists of the keyword <VAR
CLASS="LITERAL"
>ARRAY</VAR
>, a left square bracket
    <VAR
CLASS="LITERAL"
>[</VAR
>, one or more expressions (separated by commas) for the
    array element values, and finally a right square bracket <VAR
CLASS="LITERAL"
>]</VAR
>.
    For example,
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</PRE
><P>
    The array element type is the common type of the member expressions,
    determined using the same rules as for <VAR
CLASS="LITERAL"
>UNION</VAR
> or
    <VAR
CLASS="LITERAL"
>CASE</VAR
> constructs (see <A
HREF="typeconv-union-case.html"
>Section 10.5</A
>). 
   </P
><P
>    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the keyword <VAR
CLASS="LITERAL"
>ARRAY</VAR
> may
    be omitted.  For example, these produce the same result:

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</PRE
><P>

    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
  </P
><P
>    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<VAR
CLASS="LITERAL"
>ARRAY</VAR
> construct.
    For example:
</P><PRE
CLASS="PROGRAMLISTING"
>create table arr(f1 int[], f2 int[]);
CREATE TABLE
insert into arr values (ARRAY[[1,2],[3,4]],ARRAY[[5,6],[7,8]]);
INSERT 2635544 1
select ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] from arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</PRE
><P>
  </P
><P
>   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   keyword <VAR
CLASS="LITERAL"
>ARRAY</VAR
> followed by a parenthesized (not
   bracketed) subquery. For example:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                          ?column?
-------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31}
(1 row)</PRE
><P>
  The sub-select must return a single column. The
  resulting one-dimensional array will have an element for each row in the
  sub-select result, with an element type matching that of the sub-select's
  output column.
  </P
><P
>   The subscripts of an array value built with <VAR
CLASS="LITERAL"
>ARRAY</VAR
>
   always begin with one.  For more information about arrays, see
   <A
HREF="arrays.html"
>Section 8.10</A
>.
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYNTAX-EXPRESS-EVAL"
>4.2.9. Expression Evaluation Rules</A
></H2
><A
NAME="AEN1714"
></A
><P
>    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
   </P
><P
>    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT true OR somefunc();</PRE
><P>
    then <VAR
CLASS="LITERAL"
>somefunc()</VAR
> would (probably) not be called
    at all. The same would be the case if one wrote
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT somefunc() OR true;</PRE
><P>
    Note that this is not the same as the left-to-right
    <SPAN
CLASS="QUOTE"
>"short-circuiting"</SPAN
> of Boolean operators that is found
    in some programming languages.
   </P
><P
>    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <VAR
CLASS="LITERAL"
>WHERE</VAR
> and <VAR
CLASS="LITERAL"
>HAVING</VAR
> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<VAR
CLASS="LITERAL"
>AND</VAR
>/<VAR
CLASS="LITERAL"
>OR</VAR
>/<VAR
CLASS="LITERAL"
>NOT</VAR
> combinations) in those clauses may be reorganized
    in any manner allowed by the laws of Boolean algebra.
   </P
><P
>    When it is essential to force evaluation order, a <VAR
CLASS="LITERAL"
>CASE</VAR
>
    construct (see <A
HREF="functions-conditional.html"
>Section 9.12</A
>) may be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <VAR
CLASS="LITERAL"
>WHERE</VAR
> clause:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT ... WHERE x &lt;&gt; 0 AND y/x &gt; 1.5;</PRE
><P>
    But this is safe:
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;</PRE
><P>
    A <VAR
CLASS="LITERAL"
>CASE</VAR
> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would doubtless be best to sidestep the problem by writing
    <VAR
CLASS="LITERAL"
>y &gt; 1.5*x</VAR
> instead.)
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="ddl.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>SQL Syntax</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Data Definition</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>