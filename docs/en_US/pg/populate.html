<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>13.4. Populating a Database</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.70.0">
<link rel="start" href="index.html" title="PostgreSQL 8.0.8 Documentation">
<link rel="up" href="performance-tips.html" title="Chapter 13. Performance Tips">
<link rel="prev" href="explicit-joins.html" title="13.3. Controlling the Planner with Explicit JOIN Clauses">
<link rel="next" href="admin.html" title="Part III. Server Administration">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="populate"></a>13.4. Populating a Database</h2></div></div></div>
<p>   One may need to insert a large amount of data when first populating
   a database. This section contains some suggestions on how to make
   this process as efficient as possible.
  </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="disable-autocommit"></a>13.4.1. Disable Autocommit</h3></div></div></div>
<a name="id629074"></a><p>    Turn off autocommit and just do one commit at the end.  (In plain
    SQL, this means issuing <code class="command">BEGIN</code> at the start and
    <code class="command">COMMIT</code> at the end.  Some client libraries may
    do this behind your back, in which case you need to make sure the
    library does it when you want it done.)  If you allow each
    insertion to be committed separately,
    <span class="productname">PostgreSQL</span> is doing a lot of work for
    each row that is added.  An additional benefit of doing all
    insertions in one transaction is that if the insertion of one row
    were to fail then the insertion of all rows inserted up to that
    point would be rolled back, so you won't be stuck with partially
    loaded data.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="populate-copy-from"></a>13.4.2. Use <code class="command">COPY</code></h3></div></div></div>
<p>    Use <a href="sql-copy.html">COPY</a> to load
    all the rows in one command, instead of using a series of
    <code class="command">INSERT</code> commands.  The <code class="command">COPY</code>
    command is optimized for loading large numbers of rows; it is less
    flexible than <code class="command">INSERT</code>, but incurs significantly
    less overhead for large data loads. Since <code class="command">COPY</code>
    is a single command, there is no need to disable autocommit if you
    use this method to populate a table.
   </p>
<p>    If you cannot use <code class="command">COPY</code>, it may help to use <a href="sql-prepare.html">PREPARE</a> to create a
    prepared <code class="command">INSERT</code> statement, and then use
    <code class="command">EXECUTE</code> as many times as required.  This avoids
    some of the overhead of repeatedly parsing and planning
    <code class="command">INSERT</code>.
   </p>
<p>    Note that loading a large number of rows using
    <code class="command">COPY</code> is almost always faster than using
    <code class="command">INSERT</code>, even if <code class="command">PREPARE</code> is used and
    multiple insertions are batched into a single transaction.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="populate-rm-indexes"></a>13.4.3. Remove Indexes</h3></div></div></div>
<p>    If you are loading a freshly created table, the fastest way is to
    create the table, bulk load the table's data using
    <code class="command">COPY</code>, then create any indexes needed for the
    table.  Creating an index on pre-existing data is quicker than
    updating it incrementally as each row is loaded.
   </p>
<p>    If you are augmenting an existing table, you can drop the index,
    load the table, and then recreate the index. Of course, the
    database performance for other users may be adversely affected
    during the time that the index is missing.  One should also think
    twice before dropping unique indexes, since the error checking
    afforded by the unique constraint will be lost while the index is
    missing.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="populate-work-mem"></a>13.4.4. Increase <code class="varname">maintenance_work_mem</code></h3></div></div></div>
<p>    Temporarily increasing the <a href="runtime-config.html#guc-maintenance-work-mem">maintenance_work_mem</a>
    configuration variable when loading large amounts of data can
    lead to improved performance. This is because when a B-tree index
    is created from scratch, the existing content of the table needs
    to be sorted. Allowing the merge sort to use more memory
    means that fewer merge passes will be required.  A larger setting for
    <code class="varname">maintenance_work_mem</code> may also speed up validation
    of foreign-key constraints.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="populate-checkpoint-segments"></a>13.4.5. Increase <code class="varname">checkpoint_segments</code></h3></div></div></div>
<p>    Temporarily increasing the <a href="runtime-config.html#guc-checkpoint-segments">checkpoint_segments</a> configuration variable can also
    make large data loads faster.  This is because loading a large
    amount of data into <span class="productname">PostgreSQL</span> can
    cause checkpoints to occur more often than the normal checkpoint
    frequency (specified by the <code class="varname">checkpoint_timeout</code>
    configuration variable). Whenever a checkpoint occurs, all dirty
    pages must be flushed to disk. By increasing
    <code class="varname">checkpoint_segments</code> temporarily during bulk
    data loads, the number of checkpoints that are required can be
    reduced.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="populate-analyze"></a>13.4.6. Run <code class="command">ANALYZE</code> Afterwards</h3></div></div></div>
<p>    Whenever you have significantly altered the distribution of data
    within a table, running <a href="sql-analyze.html">ANALYZE</a> is strongly recommended. This
    includes bulk loading large amounts of data into the table.  Running
    <code class="command">ANALYZE</code> (or <code class="command">VACUUM ANALYZE</code>)
    ensures that the planner has up-to-date statistics about the
    table.  With no statistics or obsolete statistics, the planner may
    make poor decisions during query planning, leading to poor
    performance on any tables with inaccurate or nonexistent
    statistics.
   </p>
</div>
</div></body>
</html>
