<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>23.3. On-line backup and point-in-time recovery (PITR)</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<link rel="start" href="index.html" title="PostgreSQL 8.1.10 Documentation">
<link rel="up" href="backup.html" title="Chapter 23. Backup and Restore">
<link rel="prev" href="backup-file.html" title="23.2. File system level backup">
<link rel="next" href="migration.html" title="23.4. Migration Between Releases">
<link rel="copyright" href="ln-legalnotice.html" title="Legal Notice">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both" id="backup-online">23.3. On-line backup and point-in-time recovery (PITR)</h2></div></div></div>
<a name="id2674718"></a><a name="id2674727"></a><a name="id2674736"></a><p>   At all times, <span class="productname">PostgreSQL</span> maintains a
   <em class="firstterm">write ahead log</em> (WAL) in the <code class="filename">pg_xlog/</code>
   subdirectory of the cluster's data directory. The log describes
   every change made to the database's data files.  This log exists
   primarily for crash-safety purposes: if the system crashes, the
   database can be restored to consistency by &#8220;<span class="quote">replaying</span>&#8221; the
   log entries made since the last checkpoint.  However, the existence
   of the log makes it possible to use a third strategy for backing up
   databases: we can combine a file-system-level backup with backup of
   the WAL files.  If recovery is needed, we restore the backup and
   then replay from the backed-up WAL files to bring the backup up to
   current time.  This approach is more complex to administer than
   either of the previous approaches, but it has some significant
   benefits:
  </p>
<div class="itemizedlist"><ul type="disc">
<li><p>     We do not need a perfectly consistent backup as the starting point.
     Any internal inconsistency in the backup will be corrected by log
     replay (this is not significantly different from what happens during
     crash recovery).  So we don't need file system snapshot capability,
     just <span class="application">tar</span> or a similar archiving tool.
    </p></li>
<li><p>     Since we can string together an indefinitely long sequence of WAL files
     for replay, continuous backup can be achieved simply by continuing to archive
     the WAL files.  This is particularly valuable for large databases, where
     it may not be convenient to take a full backup frequently.
    </p></li>
<li><p>     There is nothing that says we have to replay the WAL entries all the
     way to the end.  We could stop the replay at any point and have a
     consistent snapshot of the database as it was at that time.  Thus,
     this technique supports <em class="firstterm">point-in-time recovery</em>: it is
     possible to restore the database to its state at any time since your base
     backup was taken.
    </p></li>
<li><p>     If we continuously feed the series of WAL files to another
     machine that has been loaded with the same base backup file, we
     have a &#8220;<span class="quote">hot standby</span>&#8221; system: at any point we can bring up
     the second machine and it will have a nearly-current copy of the
     database.
    </p></li>
</ul></div>
<p>
  </p>
<p>   As with the plain file-system-backup technique, this method can only
   support restoration of an entire database cluster, not a subset.
   Also, it requires a lot of archival storage: the base backup may be bulky,
   and a busy system will generate many megabytes of WAL traffic that
   have to be archived.  Still, it is the preferred backup technique in
   many situations where high reliability is needed.
  </p>
<p>   To recover successfully using an on-line backup, you need a continuous
   sequence of archived WAL files that extends back at least as far as the
   start time of your backup.  So to get started, you should set up and test
   your procedure for archiving WAL files <span class="emphasis"><em>before</em></span> you take your
   first base backup.  Accordingly, we first discuss the mechanics of
   archiving WAL files.
  </p>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title" id="backup-archiving-wal">23.3.1. Setting up WAL archiving</h3></div></div></div>
<p>    In an abstract sense, a running <span class="productname">PostgreSQL</span> system
    produces an indefinitely long sequence of WAL records.  The system
    physically divides this sequence into WAL <em class="firstterm">segment
    files</em>, which are normally 16MB apiece (although the size can be
    altered when building <span class="productname">PostgreSQL</span>).  The segment
    files are given numeric names that reflect their position in the
    abstract WAL sequence.  When not using WAL archiving, the system
    normally creates just a few segment files and then
    &#8220;<span class="quote">recycles</span>&#8221; them by renaming no-longer-needed segment files
    to higher segment numbers.  It's assumed that a segment file whose
    contents precede the checkpoint-before-last is no longer of
    interest and can be recycled.
   </p>
<p>    When archiving WAL data, we want to capture the contents of each segment
    file once it is filled, and save that data somewhere before the segment
    file is recycled for reuse.  Depending on the application and the
    available hardware, there could be many different ways of &#8220;<span class="quote">saving
    the data somewhere</span>&#8221;: we could copy the segment files to an NFS-mounted
    directory on another machine, write them onto a tape drive (ensuring that
    you have a way of restoring the file with its original file name), or batch
    them together and burn them onto CDs, or something else entirely.  To
    provide the database administrator with as much flexibility as possible,
    <span class="productname">PostgreSQL</span> tries not to make any assumptions about how 
    the archiving will be done.  Instead, <span class="productname">PostgreSQL</span> lets
    the administrator specify a shell command to be executed to copy a
    completed segment file to wherever it needs to go.  The command could be
    as simple as a <span class="application">cp</span>, or it could invoke a complex shell
    script [mdash ] it's all up to you.
   </p>
<p>    The shell command to use is specified by the <a class="xref" href="runtime-config-wal.html#guc-archive-command">archive_command</a> configuration parameter, which in practice
    will always be placed in the <code class="filename">postgresql.conf</code> file.
    In this string,
    any <code class="literal">%p</code> is replaced by the path name of the file to
    archive, while any <code class="literal">%f</code> is replaced by the file name only.
    (The path name is relative to the working directory of the server,
    i.e., the cluster's data directory.)
    Write <code class="literal">%%</code> if you need to embed an actual <code class="literal">%</code>
    character in the command.  The simplest useful command is something
    like
</p>
<pre class="programlisting">archive_command = 'cp -i %p /mnt/server/archivedir/%f &lt;/dev/null'</pre>
<p>
    which will copy archivable WAL segments to the directory
    <code class="filename">/mnt/server/archivedir</code>.  (This is an example, not a 
    recommendation, and may not work on all platforms.)
   </p>
<p>    The archive command will be executed under the ownership of the same
    user that the <span class="productname">PostgreSQL</span> server is running as.  Since
    the series of WAL files being archived contains effectively everything
    in your database, you will want to be sure that the archived data is
    protected from prying eyes; for example, archive into a directory that
    does not have group or world read access.
   </p>
<p>    It is important that the archive command return zero exit status if and
    only if it succeeded.  Upon getting a zero result,
    <span class="productname">PostgreSQL</span> will assume that the WAL segment file has been
    successfully archived, and will remove or recycle it.
    However, a nonzero status tells
    <span class="productname">PostgreSQL</span> that the file was not archived; it will try
    again periodically until it succeeds.
   </p>
<p>    The archive command should generally be designed to refuse to overwrite
    any pre-existing archive file.  This is an important safety feature to
    preserve the integrity of your archive in case of administrator error
    (such as sending the output of two different servers to the same archive
    directory).
    It is advisable to test your proposed archive command to ensure that it
    indeed does not overwrite an existing file, <span class="emphasis"><em>and that it returns
    nonzero status in this case</em></span>.  We have found that <code class="literal">cp -i</code> does
    this correctly on some platforms but not others.  If the chosen command
    does not itself handle this case correctly, you should add a command
    to test for pre-existence of the archive file.  For example, something
    like
</p>
<pre class="programlisting">archive_command = 'test ! -f .../%f &amp;&amp; cp %p .../%f'</pre>
<p>
    works correctly on most Unix variants.
   </p>
<p>    While designing your archiving setup, consider what will happen if
    the archive command fails repeatedly because some aspect requires 
    operator intervention or the archive runs out of space. For example, this
    could occur if you write to tape without an autochanger; when the tape 
    fills, nothing further can be archived until the tape is swapped.
    You should ensure that any error condition or request to a human operator
    is reported appropriately so that the situation can be 
    resolved relatively quickly. The <code class="filename">pg_xlog/</code> directory will
    continue to fill with WAL segment files until the situation is resolved.
   </p>
<p>    The speed of the archiving command is not important, so long as it can keep up
    with the average rate at which your server generates WAL data.  Normal
    operation continues even if the archiving process falls a little behind.
    If archiving falls significantly behind, this will increase the amount of
    data that would be lost in the event of a disaster. It will also mean that
    the <code class="filename">pg_xlog/</code> directory will contain large numbers of
    not-yet-archived segment files, which could eventually exceed available
    disk space. You are advised to monitor the archiving process to ensure that
    it is working as you intend.
   </p>
<p>    If you are concerned about being able to recover right up to the
    current instant, you may want to take additional steps to ensure that
    the current, partially-filled WAL segment is also copied someplace.
    This is particularly important if your server generates only little WAL
    traffic (or has slack periods where it does so), since it could take a
    long time before a WAL segment file is completely filled and ready to
    archive.  One possible way to handle this is to set up a
    <span class="application">cron</span> job that periodically (once a minute, perhaps)
    identifies the current WAL segment file and saves it someplace safe.
    Then the combination of the archived WAL segments and the saved current
    segment will be enough to ensure you can always restore to within a
    minute of current time.  This behavior is not presently built into
    <span class="productname">PostgreSQL</span> because we did not want to complicate the
    definition of the <a class="xref" href="runtime-config-wal.html#guc-archive-command">archive_command</a> by requiring it
    to keep track of successively archived, but different, copies of the
    same WAL file.  The <a class="xref" href="runtime-config-wal.html#guc-archive-command">archive_command</a> is only
    invoked on completed WAL segments. Except in the case of retrying a
    failure, it will be called only once for any given file name.
   </p>
<p>    In writing your archive command, you should assume that the file names to
    be archived may be up to 64 characters long and may contain any
    combination of ASCII letters, digits, and dots.  It is not necessary to
    remember the original full path (<code class="literal">%p</code>) but it is necessary to
    remember the file name (<code class="literal">%f</code>).
   </p>
<p>    Note that although WAL archiving will allow you to restore any
    modifications made to the data in your <span class="productname">PostgreSQL</span> database
    it will not restore changes made to configuration files (that is,
    <code class="filename">postgresql.conf</code>, <code class="filename">pg_hba.conf</code> and
    <code class="filename">pg_ident.conf</code>), since those are edited manually rather
    than through SQL operations.
    You may wish to keep the configuration files in a location that will
    be backed up by your regular file system backup procedures.  See
    <a class="xref" href="runtime-config-file-locations.html" title="17.2. File Locations">Section 17.2, &#8220;File Locations&#8221;</a> for how to relocate the
    configuration files.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title" id="backup-base-backup">23.3.2. Making a Base Backup</h3></div></div></div>
<p>    The procedure for making a base backup is relatively simple:
  </p>
<div class="orderedlist"><ol type="1">
<li><p>     Ensure that WAL archiving is enabled and working.
    </p></li>
<li>
<p>     Connect to the database as a superuser, and issue the command
</p>
<pre class="programlisting">SELECT pg_start_backup('label');</pre>
<p>
     where <code class="literal">label</code> is any string you want to use to uniquely
     identify this backup operation.  (One good practice is to use the
     full path where you intend to put the backup dump file.)
     <code class="function">pg_start_backup</code> creates a <em class="firstterm">backup label</em> file,
     called <code class="filename">backup_label</code>, in the cluster directory with
     information about your backup.
    </p>
<p>     It does not matter which database within the cluster you connect to to 
     issue this command.  You can ignore the result returned by the function;
     but if it reports an error, deal with that before proceeding.
    </p>
</li>
<li><p>     Perform the backup, using any convenient file-system-backup tool
     such as <span class="application">tar</span> or <span class="application">cpio</span>.  It is neither
     necessary nor desirable to stop normal operation of the database
     while you do this.
    </p></li>
<li>
<p>     Again connect to the database as a superuser, and issue the command
</p>
<pre class="programlisting">SELECT pg_stop_backup();</pre>
<p>
     This should return successfully.
    </p>
</li>
<li><p>     Once the WAL segment files used during the backup are archived as part
     of normal database activity, you are done.
    </p></li>
</ol></div>
<p>
   </p>
<p>    Some backup tools that you might wish to use emit warnings or errors
    if the files they are trying to copy change while the copy proceeds.
    This situation is normal, and not an error, when taking a base backup of
    an active database; so you need to ensure that you can distinguish
    complaints of this sort from real errors.  For example, some versions
    of <span class="application">rsync</span> return a separate exit code for &#8220;<span class="quote">vanished
    source files</span>&#8221;, and you can write a driver script to accept this exit
    code as a non-error case.  Also,
    some versions of GNU <span class="application">tar</span> consider it an error if a file
    is changed while <span class="application">tar</span> is copying it.  There does not seem
    to be any very convenient way to distinguish this error from other types
    of errors, other than manual inspection of <span class="application">tar</span>'s messages.
    GNU <span class="application">tar</span> is therefore not the best tool for making base
    backups.
   </p>
<p>    It is not necessary to be very concerned about the amount of time elapsed
    between <code class="function">pg_start_backup</code> and the start of the actual backup,
    nor between the end of the backup and <code class="function">pg_stop_backup</code>; a
    few minutes' delay won't hurt anything.  You
    must however be quite sure that these operations are carried out in
    sequence and do not overlap.
   </p>
<p>    Be certain that your backup dump includes all of the files underneath
    the database cluster directory (e.g., <code class="filename">/usr/local/pgsql/data</code>).
    If you are using tablespaces that do not reside underneath this directory,
    be careful to include them as well (and be sure that your backup dump
    archives symbolic links as links, otherwise the restore will mess up
    your tablespaces).
   </p>
<p>    You may, however, omit from the backup dump the files within the
    <code class="filename">pg_xlog/</code> subdirectory of the cluster directory.  This
    slight complication is worthwhile because it reduces the risk
    of mistakes when restoring.  This is easy to arrange if
    <code class="filename">pg_xlog/</code> is a symbolic link pointing to someplace outside
    the cluster directory, which is a common setup anyway for performance
    reasons.
   </p>
<p>    To make use of this backup, you will need to keep around all the WAL
    segment files generated during and after the file system backup.
    To aid you in doing this, the <code class="function">pg_stop_backup</code> function
    creates a <em class="firstterm">backup history file</em> that is immediately
    stored into the WAL archive area. This file is named after the first
    WAL segment file that you need to have to make use of the backup.
    For example, if the starting WAL file is
    <code class="literal">0000000100001234000055CD</code> the backup history file will be
    named something like
    <code class="literal">0000000100001234000055CD.007C9330.backup</code>. (The second
    number in the file name stands for an exact position within the WAL
    file, and can ordinarily be ignored.) Once you have safely archived
    the file system backup and the WAL segment files used during the
    backup (as specified in the backup history file), all archived WAL
    segments with names numerically less are no longer needed to recover
    the file system backup and may be deleted. However, you should
    consider keeping several backup sets to be absolutely certain that
    you can recover your data. Keep in mind that only completed WAL
    segment files are archived, so there will be delay between running
    <code class="function">pg_stop_backup</code> and the archiving of all WAL segment
    files needed to make the file system backup consistent.
   </p>
<p>    The backup history file is just a small text file. It contains the
    label string you gave to <code class="function">pg_start_backup</code>, as well as
    the starting and ending times and WAL segments of the backup.
    If you used the label to identify where the associated dump file is kept, 
    then the archived history file is enough to tell you which dump file to
    restore, should you need to do so.
   </p>
<p>    Since you have to keep around all the archived WAL files back to your
    last base backup, the interval between base backups should usually be
    chosen based on how much storage you want to expend on archived WAL
    files.  You should also consider how long you are prepared to spend
    recovering, if recovery should be necessary [mdash ] the system will have to
    replay all those WAL segments, and that could take awhile if it has
    been a long time since the last base backup.
   </p>
<p>    It's also worth noting that the <code class="function">pg_start_backup</code> function
    makes a file named <code class="filename">backup_label</code> in the database cluster
    directory, which is then removed again by <code class="function">pg_stop_backup</code>.
    This file will of course be archived as a part of your backup dump file.
    The backup label file includes the label string you gave to
    <code class="function">pg_start_backup</code>, as well as the time at which
    <code class="function">pg_start_backup</code> was run, and the name of the starting WAL
    file.  In case of confusion it will
    therefore be possible to look inside a backup dump file and determine
    exactly which backup session the dump file came from.
   </p>
<p>    It is also possible to make a backup dump while the postmaster is
    stopped.  In this case, you obviously cannot use
    <code class="function">pg_start_backup</code> or <code class="function">pg_stop_backup</code>, and
    you will therefore be left to your own devices to keep track of which
    backup dump is which and how far back the associated WAL files go.
    It is generally better to follow the on-line backup procedure above.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title" id="backup-pitr-recovery">23.3.3. Recovering with an On-line Backup</h3></div></div></div>
<p>    Okay, the worst has happened and you need to recover from your backup.
    Here is the procedure:
  </p>
<div class="orderedlist"><ol type="1">
<li><p>     Stop the postmaster, if it's running.
    </p></li>
<li><p>     If you have the space to do so,
     copy the whole cluster data directory and any tablespaces to a temporary 
     location in case you need them later. Note that this precaution will
     require that you have enough free space on your system to hold two
     copies of your existing database. If you do not have enough space, 
     you need at the least to copy the contents of the <code class="filename">pg_xlog</code>
     subdirectory of the cluster data directory, as it may contain logs which
     were not archived before the system went down.
    </p></li>
<li><p>     Clean out all existing files and subdirectories under the cluster data
     directory and under the root directories of any tablespaces you are using.
    </p></li>
<li><p>     Restore the database files from your backup dump.  Be careful that they
     are restored with the right ownership (the database system user, not
     root!) and with the right permissions.  If you are using tablespaces,
     you may want to verify that the symbolic links in <code class="filename">pg_tblspc/</code>
     were correctly restored.
    </p></li>
<li><p>     Remove any files present in <code class="filename">pg_xlog/</code>; these came from the
     backup dump and are therefore probably obsolete rather than current.
     If you didn't archive <code class="filename">pg_xlog/</code> at all, then re-create it,
     and be sure to re-create the subdirectory
    <code class="filename">pg_xlog/archive_status/</code> as well.
    </p></li>
<li><p>     If you had unarchived WAL segment files that you saved in step 2,
     copy them into <code class="filename">pg_xlog/</code>.  (It is best to copy them,
     not move them, so that you still have the unmodified files if a
     problem occurs and you have to start over.)
    </p></li>
<li><p>     Create a recovery command file <code class="filename">recovery.conf</code> in the cluster
     data directory (see <a class="xref" href="backup-online.html#recovery-config-settings" title="23.3.3.1. Recovery Settings">Recovery Settings</a>). You may 
     also want to temporarily modify <code class="filename">pg_hba.conf</code> to prevent 
     ordinary users from connecting until you are sure the recovery has worked.
    </p></li>
<li><p>     Start the postmaster.  The postmaster will go into recovery mode and
     proceed to read through the archived WAL files it needs.  Upon completion
     of the recovery process, the postmaster will rename
     <code class="filename">recovery.conf</code> to <code class="filename">recovery.done</code> (to prevent
     accidentally re-entering recovery mode in case of a crash later) and then
     commence normal database operations.
    </p></li>
<li><p>     Inspect the contents of the database to ensure you have recovered to
     where you want to be.  If not, return to step 1.  If all is well,
     let in your users by restoring <code class="filename">pg_hba.conf</code> to normal.
    </p></li>
</ol></div>
<p>
   </p>
<p>    The key part of all this is to set up a recovery command file that
    describes how you want to recover and how far the recovery should
    run.  You can use <code class="filename">recovery.conf.sample</code> (normally
    installed in the installation <code class="filename">share/</code> directory) as a
    prototype.  The one thing that you absolutely must specify in
    <code class="filename">recovery.conf</code> is the <code class="varname">restore_command</code>,
    which tells <span class="productname">PostgreSQL</span> how to get back archived
    WAL file segments.  Like the <code class="varname">archive_command</code>, this is
    a shell command string.  It may contain <code class="literal">%f</code>, which is
    replaced by the name of the desired log file, and <code class="literal">%p</code>,
    which is replaced by the path name to copy the log file to.
    (The path name is relative to the working directory of the server,
    i.e., the cluster's data directory.)
    Write <code class="literal">%%</code> if you need to embed an actual <code class="literal">%</code>
    character in the command.  The simplest useful command is
    something like
</p>
<pre class="programlisting">restore_command = 'cp /mnt/server/archivedir/%f %p'</pre>
<p>
    which will copy previously archived WAL segments from the directory
    <code class="filename">/mnt/server/archivedir</code>.  You could of course use something
    much more complicated, perhaps even a shell script that requests the
    operator to mount an appropriate tape.
   </p>
<p>    It is important that the command return nonzero exit status on failure.
    The command <span class="emphasis"><em>will</em></span> be asked for log files that are not present
    in the archive; it must return nonzero when so asked.  This is not an
    error condition.  Be aware also that the base name of the <code class="literal">%p</code>
    path will be different from <code class="literal">%f</code>; do not expect them to be
    interchangeable.
   </p>
<p>    WAL segments that cannot be found in the archive will be sought in
    <code class="filename">pg_xlog/</code>; this allows use of recent un-archived segments.
    However segments that are available from the archive will be used in
    preference to files in <code class="filename">pg_xlog/</code>.  The system will not
    overwrite the existing contents of <code class="filename">pg_xlog/</code> when retrieving
    archived files.
   </p>
<p>    Normally, recovery will proceed through all available WAL segments,
    thereby restoring the database to the current point in time (or as
    close as we can get given the available WAL segments).  But if you want
    to recover to some previous point in time (say, right before the junior
    DBA dropped your main transaction table), just specify the required
    stopping point in <code class="filename">recovery.conf</code>.  You can specify the stop
    point, known as the &#8220;<span class="quote">recovery target</span>&#8221;, either by date/time or
    by completion of a specific transaction ID.  As of this writing only
    the date/time option is very usable, since there are no tools to help
    you identify with any accuracy which transaction ID to use.
   </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>      The stop point must be after the ending time of the base backup (the
      time of <code class="function">pg_stop_backup</code>).  You cannot use a base backup
      to recover to a time when that backup was still going on.  (To
      recover to such a time, you must go back to your previous base backup
      and roll forward from there.)
     </p>
</div>
<div class="sect3" lang="en">
<div class="titlepage"><div><div><h4 class="title" id="recovery-config-settings">23.3.3.1. Recovery Settings</h4></div></div></div>
<p>      These settings can only be made in the <code class="filename">recovery.conf</code>
      file, and apply only for the duration of the recovery. They must be
      reset for any subsequent recovery you wish to perform. They cannot be
      changed once recovery has begun.
     </p>
<div class="variablelist"><dl>
<dt>
<a name="restore-command"></a><span class="term"><code class="varname">restore_command</code> (<code class="type">string</code>)</span>
</dt>
<dd>
<p>        The shell command to execute to retrieve an archived segment of
        the WAL file series. This parameter is required.
        Any <code class="literal">%f</code> in the string is
        replaced by the name of the file to retrieve from the archive,
        and any <code class="literal">%p</code> is replaced by the path name to copy
        it to on the server.
        (The path name is relative to the working directory of the server,
        i.e., the cluster's data directory.)
        Write <code class="literal">%%</code> to embed an actual <code class="literal">%</code> character
        in the command. 
       </p>
<p>        It is important for the command to return a zero exit status if and
        only if it succeeds.  The command <span class="emphasis"><em>will</em></span> be asked for file
        names that are not present in the archive; it must return nonzero
        when so asked.  Examples:
</p>
<pre class="programlisting">restore_command = 'cp /mnt/server/archivedir/%f "%p"'
restore_command = 'copy /mnt/server/archivedir/%f "%p"'  # Windows</pre>
<p>
       </p>
</dd>
<dt>
<a name="recovery-target-time"></a><span class="term"><code class="varname">recovery_target_time</code> 
           (<code class="type">timestamp</code>)
      </span>
</dt>
<dd><p>        This parameter specifies the time stamp up to which recovery
        will proceed.
        At most one of <code class="varname">recovery_target_time</code> and
        <a class="xref" href="backup-online.html#recovery-target-xid">recovery_target_xid</a> can be specified.
        The default is to recover to the end of the WAL log.
        The precise stopping point is also influenced by 
        <a class="xref" href="backup-online.html#recovery-target-inclusive">recovery_target_inclusive</a>.
       </p></dd>
<dt>
<a name="recovery-target-xid"></a><span class="term"><code class="varname">recovery_target_xid</code> (<code class="type">string</code>)</span>
</dt>
<dd><p>        This parameter specifies the transaction ID up to which recovery
        will proceed. Keep in mind 
        that while transaction IDs are assigned sequentially at transaction 
        start, transactions can complete in a different numeric order.
        The transactions that will be recovered are those that committed
        before (and optionally including) the specified one.
        At most one of <code class="varname">recovery_target_xid</code> and
        <a class="xref" href="backup-online.html#recovery-target-time">recovery_target_time</a> can be specified.
        The default is to recover to the end of the WAL log.
        The precise stopping point is also influenced by 
        <a class="xref" href="backup-online.html#recovery-target-inclusive">recovery_target_inclusive</a>.
       </p></dd>
<dt>
<a name="recovery-target-inclusive"></a><span class="term"><code class="varname">recovery_target_inclusive</code> 
        (<code class="type">boolean</code>)
      </span>
</dt>
<dd><p>        Specifies whether we stop just after the specified recovery target
        (<code class="literal">true</code>), or just before the recovery target 
        (<code class="literal">false</code>).
        Applies to both <a class="xref" href="backup-online.html#recovery-target-time">recovery_target_time</a>
        and <a class="xref" href="backup-online.html#recovery-target-xid">recovery_target_xid</a>, whichever one is
        specified for this recovery.  This indicates whether transactions
        having exactly the target commit time or ID, respectively, will
        be included in the recovery.  Default is <code class="literal">true</code>.
       </p></dd>
<dt>
<a name="recovery-target-timeline"></a><span class="term"><code class="varname">recovery_target_timeline</code> 
        (<code class="type">string</code>)
      </span>
</dt>
<dd><p>        Specifies recovering into a particular timeline.  The default is
        to recover along the same timeline that was current when the
        base backup was taken.  You would only need to set this parameter
        in complex re-recovery situations, where you need to return to
        a state that itself was reached after a point-in-time recovery.
        See <a class="xref" href="backup-online.html#backup-timelines" title="23.3.4. Timelines">Section 23.3.4, &#8220;Timelines&#8221;</a> for discussion.
       </p></dd>
</dl></div>
</div>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title" id="backup-timelines">23.3.4. Timelines</h3></div></div></div>
<a name="id2676155"></a><p>    The ability to restore the database to a previous point in time creates
    some complexities that are akin to science-fiction stories about time
    travel and parallel universes.  In the original history of the database,
    perhaps you dropped a critical table at 5:15PM on Tuesday evening.
    Unfazed, you get out your backup, restore to the point-in-time 5:14PM
    Tuesday evening, and are up and running.  In <span class="emphasis"><em>this</em></span> history of
    the database universe, you never dropped the table at all.  But suppose
    you later realize this wasn't such a great idea after all, and would like
    to return to some later point in the original history.  You won't be able
    to if, while your database was up-and-running, it overwrote some of the
    sequence of WAL segment files that led up to the time you now wish you
    could get back to.  So you really want to distinguish the series of
    WAL records generated after you've done a point-in-time recovery from
    those that were generated in the original database history.
   </p>
<p>    To deal with these problems, <span class="productname">PostgreSQL</span> has a notion
    of <em class="firstterm">timelines</em>.  Each time you recover to a point-in-time
    earlier than the end of the WAL sequence, a new timeline is created
    to identify the series of WAL records generated after that recovery.
    (If recovery proceeds all the way to the end of WAL, however, we do not
    start a new timeline: we just extend the existing one.)  The timeline
    ID number is part of WAL segment file names, and so a new timeline does
    not overwrite the WAL data generated by previous timelines.  It is
    in fact possible to archive many different timelines.  While that might
    seem like a useless feature, it's often a lifesaver.  Consider the
    situation where you aren't quite sure what point-in-time to recover to,
    and so have to do several point-in-time recoveries by trial and error
    until you find the best place to branch off from the old history.  Without
    timelines this process would soon generate an unmanageable mess.  With
    timelines, you can recover to <span class="emphasis"><em>any</em></span> prior state, including
    states in timeline branches that you later abandoned.
   </p>
<p>    Each time a new timeline is created, <span class="productname">PostgreSQL</span> creates
    a &#8220;<span class="quote">timeline history</span>&#8221; file that shows which timeline it branched
    off from and when.  These history files are necessary to allow the system
    to pick the right WAL segment files when recovering from an archive that
    contains multiple timelines.  Therefore, they are archived into the WAL
    archive area just like WAL segment files.  The history files are just
    small text files, so it's cheap and appropriate to keep them around
    indefinitely (unlike the segment files which are large).  You can, if
    you like, add comments to a history file to make your own notes about
    how and why this particular timeline came to be.  Such comments will be
    especially valuable when you have a thicket of different timelines as
    a result of experimentation.
   </p>
<p>    The default behavior of recovery is to recover along the same timeline
    that was current when the base backup was taken.  If you want to recover
    into some child timeline (that is, you want to return to some state that
    was itself generated after a recovery attempt), you need to specify the
    target timeline ID in <code class="filename">recovery.conf</code>.  You cannot recover into
    timelines that branched off earlier than the base backup.
   </p>
</div>
<div class="sect2" lang="en">
<div class="titlepage"><div><div><h3 class="title" id="backup-online-caveats">23.3.5. Caveats</h3></div></div></div>
<p>    At this writing, there are several limitations of the on-line backup
    technique.  These will probably be fixed in future releases:

  </p>
<div class="itemizedlist"><ul type="disc">
<li><p>     Operations on hash and R-tree indexes are
     not presently WAL-logged, so replay will not update these index types.
     The recommended workaround is to manually <code class="command">REINDEX</code> each
     such index after completing a recovery operation.
    </p></li>
<li><p>     If a <code class="command">CREATE DATABASE</code> command is executed while a base
     backup is being taken, and then the template database that the
     <code class="command">CREATE DATABASE</code> copied is modified while the base backup
     is still in progress, it is possible that recovery will cause those
     modifications to be propagated into the created database as well.
     This is of course undesirable.  To avoid this risk, it is best not to
     modify any template databases while taking a base backup.
    </p></li>
<li><p>     <code class="command">CREATE TABLESPACE</code> commands are WAL-logged with the literal
     absolute path, and will therefore be replayed as tablespace creations
     with the same absolute path.  This might be undesirable if the log is
     being replayed on a different machine.  It can be dangerous even if
     the log is being replayed on the same machine, but into a new data
     directory: the replay will still overwrite the contents of the original
     tablespace.  To avoid potential gotchas of this sort, the best practice
     is to take a new base backup after creating or dropping tablespaces.
    </p></li>
</ul></div>
<p>
   </p>
<p>    It should also be noted that the default <acronym class="acronym">WAL</acronym>
    format is fairly bulky since it includes many disk page snapshots.
    These page snapshots are designed to support crash recovery,
    since we may need to fix partially-written disk pages.  Depending
    on your system hardware and software, the risk of partial writes may
    be small enough to ignore, in which case you can significantly reduce
    the total volume of archived logs by turning off page snapshots 
    using the <a class="xref" href="runtime-config-wal.html#guc-full-page-writes">full_page_writes</a> parameter.
    (Read the notes and warnings in 
    <a class="xref" href="wal.html" title="Chapter 26. Reliability and the Write-Ahead Log">Chapter 26, <i>Reliability and the Write-Ahead Log</i></a> before you do so.)
    Turning off page snapshots does not prevent use of the logs for PITR
    operations.
    An area for future development is to compress archived WAL data by
    removing unnecessary page copies even when <code class="varname">full_page_writes</code>
    is on.  In the meantime, administrators
    may wish to reduce the number of page snapshots included in WAL by
    increasing the checkpoint interval parameters as much as feasible.
   </p>
</div>
</div></body>
</html>
