<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>CREATE RULE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="SQL Commands"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE OPERATOR CLASS"
HREF="sql-createopclass.html"><LINK
REL="NEXT"
TITLE="CREATE SCHEMA"
HREF="sql-createschema.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-11-16T21:52:34"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createopclass.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createopclass.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createschema.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createschema.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATERULE"
></A
>CREATE RULE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN37699"
></A
><H2
>Name</H2
>CREATE RULE&nbsp;--&nbsp;define a new rewrite rule</DIV
><A
NAME="AEN37702"
></A
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN37704"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>CREATE [ OR REPLACE ] RULE <VAR
CLASS="REPLACEABLE"
>name</VAR
> AS ON <VAR
CLASS="REPLACEABLE"
>event</VAR
>
    TO <VAR
CLASS="REPLACEABLE"
>table</VAR
> [ WHERE <VAR
CLASS="REPLACEABLE"
>condition</VAR
> ]
    DO [ INSTEAD ] { NOTHING | <VAR
CLASS="REPLACEABLE"
>command</VAR
> | ( <VAR
CLASS="REPLACEABLE"
>command</VAR
> ; <VAR
CLASS="REPLACEABLE"
>command</VAR
> ... ) }</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN37713"
></A
><H2
>Description</H2
><P
>   <TT
CLASS="COMMAND"
>CREATE RULE</TT
> defines a new rule applying to a specified
   table or view.
   <TT
CLASS="COMMAND"
>CREATE OR REPLACE RULE</TT
> will either create a
   new rule, or replace an existing rule of the same name for the same
   table.
  </P
><P
>   The <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> rule system allows one to
   define an alternate action to be performed on insertions, updates,
   or deletions in database tables.  Roughly speaking, a rule causes
   additional commands to be executed when a given command on a given
   table is executed.  Alternatively, a rule can replace a given
   command by another, or cause a command not to be executed at all.
   Rules are used to implement table views as well.  It is important
   to realize that a rule is really a command transformation
   mechanism, or command macro.  The transformation happens before the
   execution of the commands starts.  If you actually want an
   operation that fires independently for each physical row, you
   probably want to use a trigger, not a rule.  More information about
   the rules system is in <A
HREF="rules.html"
>Chapter 34</A
>.
  </P
><P
>   Presently, <VAR
CLASS="LITERAL"
>ON SELECT</VAR
> rules must be unconditional
   <VAR
CLASS="LITERAL"
>INSTEAD</VAR
> rules and must have actions that consist
   of a single <TT
CLASS="COMMAND"
>SELECT</TT
> command.  Thus, an
   <VAR
CLASS="LITERAL"
>ON SELECT</VAR
> rule effectively turns the table into
   a view, whose visible contents are the rows returned by the rule's
   <TT
CLASS="COMMAND"
>SELECT</TT
> command rather than whatever had been
   stored in the table (if anything).  It is considered better style
   to write a <TT
CLASS="COMMAND"
>CREATE VIEW</TT
> command than to create a
   real table and define an <VAR
CLASS="LITERAL"
>ON SELECT</VAR
> rule for it.
  </P
><P
>   You can create the illusion of an updatable view by defining
   <VAR
CLASS="LITERAL"
>ON INSERT</VAR
>, <VAR
CLASS="LITERAL"
>ON UPDATE</VAR
>, and
   <VAR
CLASS="LITERAL"
>ON DELETE</VAR
> rules (or any subset of those that's
   sufficient for your purposes) to replace update actions on the view
   with appropriate updates on other tables.
  </P
><P
>   There is a catch if you try to use conditional rules for view
   updates: there <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> be an unconditional
   <VAR
CLASS="LITERAL"
>INSTEAD</VAR
> rule for each action you wish to allow
   on the view.  If the rule is conditional, or is not
   <VAR
CLASS="LITERAL"
>INSTEAD</VAR
>, then the system will still reject
   attempts to perform the update action, because it thinks it might
   end up trying to perform the action on the dummy table of the view
   in some cases.  If you want to handle all the useful cases in
   conditional rules, you can; just add an unconditional <VAR
CLASS="LITERAL"
>DO
   INSTEAD NOTHING</VAR
> rule to ensure that the system
   understands it will never be called on to update the dummy table.
   Then make the conditional rules not <VAR
CLASS="LITERAL"
>INSTEAD</VAR
>; in
   the cases where they are applied, they add to the default
   <VAR
CLASS="LITERAL"
>INSTEAD NOTHING</VAR
> action.
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN37740"
></A
><H2
>Parameters</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><VAR
CLASS="REPLACEABLE"
>name</VAR
></DT
><DD
><P
>      The name of a rule to create.  This must be distinct from the
      name of any other rule for the same table.  Multiple rules on
      the same table and same event type are applied in alphabetical
      name order.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>event</VAR
></DT
><DD
><P
>      The even is one of <VAR
CLASS="LITERAL"
>SELECT</VAR
>,
      <VAR
CLASS="LITERAL"
>INSERT</VAR
>, <VAR
CLASS="LITERAL"
>UPDATE</VAR
>, or
      <VAR
CLASS="LITERAL"
>DELETE</VAR
>.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>table</VAR
></DT
><DD
><P
>      The name (optionally schema-qualified) of the table or view the
      rule applies to.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>condition</VAR
></DT
><DD
><P
>      Any SQL conditional expression (returning <TT
CLASS="TYPE"
>boolean</TT
>).
      The condition expression may not refer to any tables except
      <VAR
CLASS="LITERAL"
>NEW</VAR
> and <VAR
CLASS="LITERAL"
>OLD</VAR
>, and may not
      contain aggregate functions.
     </P
></DD
><DT
><VAR
CLASS="REPLACEABLE"
>command</VAR
></DT
><DD
><P
>      The command or commands that make up the rule action.  Valid
      commands are <VAR
CLASS="LITERAL"
>SELECT</VAR
>,
      <VAR
CLASS="LITERAL"
>INSERT</VAR
>, <VAR
CLASS="LITERAL"
>UPDATE</VAR
>,
      <VAR
CLASS="LITERAL"
>DELETE</VAR
>, or <VAR
CLASS="LITERAL"
>NOTIFY</VAR
>.
     </P
></DD
></DL
></DIV
><P
>   Within <VAR
CLASS="REPLACEABLE"
>condition</VAR
> and
   <VAR
CLASS="REPLACEABLE"
>command</VAR
>, the special
   table names <VAR
CLASS="LITERAL"
>NEW</VAR
> and <VAR
CLASS="LITERAL"
>OLD</VAR
> may
   be used to refer to values in the referenced table.
   <VAR
CLASS="LITERAL"
>NEW</VAR
> is valid in <VAR
CLASS="LITERAL"
>ON INSERT</VAR
> and
   <VAR
CLASS="LITERAL"
>ON UPDATE</VAR
> rules to refer to the new row being
   inserted or updated.  <VAR
CLASS="LITERAL"
>OLD</VAR
> is valid in
   <VAR
CLASS="LITERAL"
>ON UPDATE</VAR
> and <VAR
CLASS="LITERAL"
>ON DELETE</VAR
> rules
   to refer to the existing row being updated or deleted.
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN37791"
></A
><H2
>Notes</H2
><P
>   You must have the privilege <VAR
CLASS="LITERAL"
>RULE</VAR
> on a table to
   be allowed to define a rule on it.
  </P
><P
>   It is very important to take care to avoid circular rules.  For
   example, though each of the following two rule definitions are
   accepted by <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, the
   <TT
CLASS="COMMAND"
>SELECT</TT
> command would cause
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> to report an error because
   the query cycled too many times:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE RULE "_RETURN" AS
    ON SELECT TO t1
    DO INSTEAD 
	SELECT * FROM t2;

CREATE RULE "_RETURN" AS
    ON SELECT TO t2
    DO INSTEAD 
	SELECT * FROM t1;

SELECT * FROM t1;</PRE
><P>
  </P
><P
>   Presently, if a rule action contains a <TT
CLASS="COMMAND"
>NOTIFY</TT
>
   command, the <TT
CLASS="COMMAND"
>NOTIFY</TT
> command will be executed
   unconditionally, that is, the <TT
CLASS="COMMAND"
>NOTIFY</TT
> will be
   issued even if there are not any rows that the rule should apply
   to.  For example, in
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE RULE notify_me AS ON UPDATE TO mytable DO NOTIFY mytable;

UPDATE mytable SET name = 'foo' WHERE id = 42;</PRE
><P>
   one <TT
CLASS="COMMAND"
>NOTIFY</TT
> event will be sent during the
   <TT
CLASS="COMMAND"
>UPDATE</TT
>, whether or not there are any rows with
   <VAR
CLASS="LITERAL"
>id = 42</VAR
>.  This is an implementation restriction
   that may be fixed in future releases.
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN37808"
></A
><H2
>Compatibility</H2
><P
>   <TT
CLASS="COMMAND"
>CREATE RULE</TT
> is a
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> language extension, as is the
   entire rules system.
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createopclass.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createschema.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE OPERATOR CLASS</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE SCHEMA</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>