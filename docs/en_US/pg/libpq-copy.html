<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Functions Associated with the COPY Command</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C Library"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="Asynchronous Notification"
HREF="libpq-notify.html"><LINK
REL="NEXT"
TITLE="Control Functions"
HREF="libpq-control.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-10-03T03:19:47"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-notify.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 27. <SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C Library</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-control.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-COPY"
>27.7. Functions Associated with the <TT
CLASS="COMMAND"
>COPY</TT
> Command</A
></H1
><A
NAME="AEN21491"
></A
><P
> The <TT
CLASS="COMMAND"
>COPY</TT
> command in <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
 has options to read from or write to the network connection used by
 <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>.  The functions described in this section
 allow applications to take advantage of this capability by supplying or
 consuming copied data.</P
><P
> The overall process is that the application first issues the SQL
 <TT
CLASS="COMMAND"
>COPY</TT
> command via <CODE
CLASS="FUNCTION"
>PQexec</CODE
> or one
 of the equivalent functions.  The response to this (if there is no error
 in the command) will be a <TT
CLASS="STRUCTNAME"
>PGresult</TT
> object bearing a status
 code of <VAR
CLASS="LITERAL"
>PGRES_COPY_OUT</VAR
> or <VAR
CLASS="LITERAL"
>PGRES_COPY_IN</VAR
>
 (depending on the specified copy direction).  The application should then
 use the functions of this section to receive or transmit data rows.
 When the data transfer is complete, another <TT
CLASS="STRUCTNAME"
>PGresult</TT
> object
 is returned to indicate success or failure of the transfer.  Its status
 will be <VAR
CLASS="LITERAL"
>PGRES_COMMAND_OK</VAR
> for success or
 <VAR
CLASS="LITERAL"
>PGRES_FATAL_ERROR</VAR
> if some problem was encountered.
 At this point further SQL commands may be issued via
 <CODE
CLASS="FUNCTION"
>PQexec</CODE
>.  (It is not possible to execute other SQL
 commands using the same connection while the <TT
CLASS="COMMAND"
>COPY</TT
>
 operation is in progress.)</P
><P
> If a <TT
CLASS="COMMAND"
>COPY</TT
> command is issued via
 <CODE
CLASS="FUNCTION"
>PQexec</CODE
> in a string that could contain additional
 commands, the application must continue fetching results via
 <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> after completing the <TT
CLASS="COMMAND"
>COPY</TT
>
 sequence.  Only when <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> returns NULL is it certain
 that the <CODE
CLASS="FUNCTION"
>PQexec</CODE
> command string is done and it is
 safe to issue more commands.</P
><P
> The functions of this section should be executed only after obtaining a
 result status of <VAR
CLASS="LITERAL"
>PGRES_COPY_OUT</VAR
> or
 <VAR
CLASS="LITERAL"
>PGRES_COPY_IN</VAR
> from <CODE
CLASS="FUNCTION"
>PQexec</CODE
> or
 <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>.</P
><P
> A <TT
CLASS="STRUCTNAME"
>PGresult</TT
> object bearing one of these status values
 carries some additional data about the <TT
CLASS="COMMAND"
>COPY</TT
> operation that
 is starting.  This additional data is available using functions that are
 also used in connection with query results:

<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQnfields</CODE
><A
NAME="AEN21528"
></A
></DT
><DD
><P
>          Returns the number of columns (fields) to be copied.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQbinaryTuples</CODE
><A
NAME="AEN21536"
></A
></DT
><DD
><P
>                0 indicates the overall copy format is textual (rows
                separated by newlines, columns separated by separator
                characters, etc).
                1 indicates the overall copy format is binary.
                See <A
HREF="sql-copy.html"
><I
>COPY</I
></A
>
                for more information.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQfformat</CODE
><A
NAME="AEN21545"
></A
></DT
><DD
><P
>          Returns the format code (0 for text, 1 for binary) associated
          with each column of the copy operation.  The per-column format
          codes will always be zero when the overall copy format is textual,
          but the binary format can support both text and binary columns.
          (However, as of the current implementation of <TT
CLASS="COMMAND"
>COPY</TT
>,
          only binary columns appear in a binary copy; so the per-column
          formats always match the overall format at present.)</P
></DD
></DL
></DIV
><P></P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>These additional data values are only available when using protocol 3.0.
When using protocol 2.0, all these functions will return 0.</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-SEND"
>27.7.1. Functions for Sending <TT
CLASS="COMMAND"
>COPY</TT
> Data</A
></H2
><P
> These functions are used to send data during <VAR
CLASS="LITERAL"
>COPY FROM STDIN</VAR
>.
 They will fail if called when the connection is not in <VAR
CLASS="LITERAL"
>COPY_IN</VAR
>
 state.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQputCopyData</CODE
><A
NAME="AEN21563"
></A
></DT
><DD
><P
> Sends data to the server during <VAR
CLASS="LITERAL"
>COPY_IN</VAR
> state.
</P><PRE
CLASS="SYNOPSIS"
>int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);</PRE
><P></P
><P
>Transmits the COPY data in the specified <VAR
CLASS="PARAMETER"
>buffer</VAR
>, of length
<VAR
CLASS="PARAMETER"
>nbytes</VAR
>, to the server.  The result is 1 if the data was sent,
zero if it was not sent because the attempt would block (this case is only
possible if the connection is in nonblock mode), or -1 if an error occurred.
(Use <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> to retrieve details if the return
value is -1.  If the value is zero, wait for write-ready and try again.)</P
><P
>The application may divide the COPY datastream into bufferloads of any
convenient size.  Bufferload boundaries have no semantic significance when
sending.  The contents of the datastream must match the data format expected
by the <TT
CLASS="COMMAND"
>COPY</TT
> command; see
<A
HREF="sql-copy.html"
><I
>COPY</I
></A
> for details.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQputCopyEnd</CODE
><A
NAME="AEN21579"
></A
></DT
><DD
><P
> Sends end-of-data indication to the server during <VAR
CLASS="LITERAL"
>COPY_IN</VAR
> state.
</P><PRE
CLASS="SYNOPSIS"
>int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);</PRE
><P></P
><P
>Ends the <VAR
CLASS="LITERAL"
>COPY_IN</VAR
> operation successfully if <VAR
CLASS="PARAMETER"
>errormsg</VAR
>
is NULL.  If <VAR
CLASS="PARAMETER"
>errormsg</VAR
> is not NULL then the <TT
CLASS="COMMAND"
>COPY</TT
>
is forced to fail, with the string pointed to by <VAR
CLASS="PARAMETER"
>errormsg</VAR
>
used as the error message.  (One should not assume that this exact error
message will come back from the server, however, as the server might have
already failed the <TT
CLASS="COMMAND"
>COPY</TT
> for its own reasons.  Also note that the
option to force failure does not work when using pre-3.0-protocol connections.)</P
><P
>The result is 1 if the termination data was sent,
zero if it was not sent because the attempt would block (this case is only
possible if the connection is in nonblock mode), or -1 if an error occurred.
(Use <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> to retrieve details if the return
value is -1.  If the value is zero, wait for write-ready and try again.)</P
><P
>After successfully calling <CODE
CLASS="FUNCTION"
>PQputCopyEnd</CODE
>, call
<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> to obtain the final result status of the
<TT
CLASS="COMMAND"
>COPY</TT
> command.  One may wait for
this result to be available in the usual way.  Then return to normal
operation.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-RECEIVE"
>27.7.2. Functions for Receiving <TT
CLASS="COMMAND"
>COPY</TT
> Data</A
></H2
><P
> These functions are used to receive data during <VAR
CLASS="LITERAL"
>COPY TO STDOUT</VAR
>.
 They will fail if called when the connection is not in <VAR
CLASS="LITERAL"
>COPY_OUT</VAR
>
 state.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
><A
NAME="AEN21608"
></A
></DT
><DD
><P
> Receives data from the server during <VAR
CLASS="LITERAL"
>COPY_OUT</VAR
> state.
</P><PRE
CLASS="SYNOPSIS"
>int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);</PRE
><P></P
><P
>Attempts to obtain another row of data from the server during a COPY.
Data is always returned one data row at a time; if only a partial row
is available, it is not returned.  Successful return of a data row
involves allocating a chunk of memory to hold the data.  The
<VAR
CLASS="PARAMETER"
>buffer</VAR
> parameter must be non-NULL.  <VAR
CLASS="PARAMETER"
>*buffer</VAR
>
is set to point to the allocated memory, or to NULL in cases where no
buffer is returned.  A non-NULL result buffer must be freed using
<CODE
CLASS="FUNCTION"
>PQfreemem</CODE
> when no longer needed.</P
><P
>When a row is successfully returned, the return value is the number of
data bytes in the row (this will always be greater than zero).  The
returned string is always null-terminated, though this is probably only
useful for textual COPY.  A result of zero indicates that the COPY is
still in progress, but no row is yet available (this is only possible
when <VAR
CLASS="PARAMETER"
>async</VAR
> is true).  A
result of -1 indicates that the COPY is done.
A result of -2 indicates that an error occurred (consult
<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> for the reason).</P
><P
>When <VAR
CLASS="PARAMETER"
>async</VAR
> is true (not zero), <CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>
will not block waiting for input; it will return zero if the COPY is still
in progress but no complete row is available.  (In this case wait for
read-ready before trying again; it does not matter whether you call
<CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
>.)  When <VAR
CLASS="PARAMETER"
>async</VAR
> is
false (zero), <CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
> will block until data is available
or the operation completes.</P
><P
>After <CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
> returns -1, call
<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> to obtain the final result status of the
<TT
CLASS="COMMAND"
>COPY</TT
> command.  One may wait for
this result to be available in the usual way.  Then return to normal
operation.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-DEPRECATED"
>27.7.3. Obsolete Functions for <TT
CLASS="COMMAND"
>COPY</TT
></A
></H2
><P
> These functions represent older methods of handling <TT
CLASS="COMMAND"
>COPY</TT
>.
 Although they still work, they are deprecated due to poor error handling,
 inconvenient methods of detecting end-of-data, and lack of support for binary
 or nonblocking transfers.</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PQgetline</CODE
><A
NAME="AEN21640"
></A
></DT
><DD
><P
>          Reads  a  newline-terminated  line  of  characters
          (transmitted  by the server) into a buffer
          string of size <VAR
CLASS="PARAMETER"
>length</VAR
>.
</P><PRE
CLASS="SYNOPSIS"
>int PQgetline(PGconn *conn,
              char *buffer,
              int length);</PRE
><P></P
><P
>This function copies up to <VAR
CLASS="PARAMETER"
>length</VAR
>-1 characters
into the buffer and converts
the terminating newline into a zero byte.
<CODE
CLASS="FUNCTION"
>PQgetline</CODE
> returns <TT
CLASS="SYMBOL"
>EOF</TT
> at the end of input, 0 if the
entire line has been read, and 1 if the buffer is full but the
terminating newline has not yet been read.</P
><P
>Note that the application must check to see if a
new line consists of  the  two characters  <VAR
CLASS="LITERAL"
>\.</VAR
>,
which  indicates  that the server has finished sending
the results  of  the <TT
CLASS="COMMAND"
>COPY</TT
> command.
If  the  application might
receive lines that are more than <VAR
CLASS="PARAMETER"
>length</VAR
>-1  characters  long,
care is needed to be sure it recognizes the <VAR
CLASS="LITERAL"
>\.</VAR
> line correctly
(and does not, for example, mistake the end of a long data line
for a terminator line).</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
><A
NAME="AEN21658"
></A
></DT
><DD
><P
>          Reads a row of COPY data
          (transmitted  by the server) into a buffer
          without blocking.
</P><PRE
CLASS="SYNOPSIS"
>int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);</PRE
><P></P
><P
>This function is similar to <CODE
CLASS="FUNCTION"
>PQgetline</CODE
>, but it can be used
by applications
that must read <TT
CLASS="COMMAND"
>COPY</TT
> data asynchronously, that is, without blocking.
Having issued the <TT
CLASS="COMMAND"
>COPY</TT
> command and gotten a <VAR
CLASS="LITERAL"
>PGRES_COPY_OUT</VAR
>
response, the
application should call <CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
> and
<CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
> until the
end-of-data signal is detected.</P
><P
>Unlike <CODE
CLASS="FUNCTION"
>PQgetline</CODE
>, this function takes
responsibility for detecting end-of-data.</P
><P
>On each call, <CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
> will return data if a
complete data row is available in <SPAN
CLASS="APPLICATION"
>libpq</SPAN
>'s input buffer.
Otherwise, no data is returned until the rest of the row arrives.
The function returns -1 if the end-of-copy-data marker has been recognized,
or 0 if no data is available, or a positive number giving the number of
bytes of data returned.  If -1 is returned, the caller must next call
<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>, and then return to normal processing.</P
><P
>The data returned will not extend beyond a data-row boundary.  If possible
a whole row will be returned at one time.  But if the buffer offered by
the caller is too small to hold a row sent by the server, then a partial
data row will be returned.  With textual data this can be detected by testing
whether the last returned byte is <VAR
CLASS="LITERAL"
>\n</VAR
> or not.  (In a binary
COPY, actual parsing of the COPY data format will be needed to make the
equivalent determination.)
The returned string is not null-terminated.  (If you want to add a
terminating null, be sure to pass a <VAR
CLASS="PARAMETER"
>bufsize</VAR
> one smaller
than the room actually available.)</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQputline</CODE
><A
NAME="AEN21682"
></A
></DT
><DD
><P
>Sends  a  null-terminated  string  to  the server.
Returns 0 if OK and <TT
CLASS="SYMBOL"
>EOF</TT
> if unable to send the string.
</P><PRE
CLASS="SYNOPSIS"
>int PQputline(PGconn *conn,
              const char *string);</PRE
><P></P
><P
>The COPY datastream sent by a series of calls to
<CODE
CLASS="FUNCTION"
>PQputline</CODE
> has the same format as that returned by
<CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
>, except that applications are not
obliged to send exactly one data row per <CODE
CLASS="FUNCTION"
>PQputline</CODE
>
call; it is okay to send a partial line or multiple lines per call.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>Before <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> protocol 3.0, it was necessary
for the application to explicitly send the two characters
<VAR
CLASS="LITERAL"
>\.</VAR
> as a final line to indicate to the server that it had
finished sending COPY data.  While this still works, it is deprecated and the
special meaning of <VAR
CLASS="LITERAL"
>\.</VAR
> can be expected to be removed in a
future release.  It is sufficient to call <CODE
CLASS="FUNCTION"
>PQendcopy</CODE
> after
having sent the actual data.</P
></BLOCKQUOTE
></DIV
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQputnbytes</CODE
><A
NAME="AEN21701"
></A
></DT
><DD
><P
>Sends  a  non-null-terminated  string  to  the server.
Returns 0 if OK and <TT
CLASS="SYMBOL"
>EOF</TT
> if unable to send the string.
</P><PRE
CLASS="SYNOPSIS"
>int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);</PRE
><P></P
><P
>This is exactly like <CODE
CLASS="FUNCTION"
>PQputline</CODE
>, except that the data
buffer need not be null-terminated since the number of bytes to send is
specified directly.  Use this procedure when sending binary data.</P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PQendcopy</CODE
><A
NAME="AEN21712"
></A
></DT
><DD
><P
> Synchronizes with the server.
</P><PRE
CLASS="SYNOPSIS"
>int PQendcopy(PGconn *conn);</PRE
><P>
 This function waits until
 the  server  has  finished  the copying.  It should
 either be issued when the  last  string  has  been
 sent  to  the  server using <CODE
CLASS="FUNCTION"
>PQputline</CODE
> or when the
 last string has been  received  from  the  server
 using <CODE
CLASS="FUNCTION"
>PGgetline</CODE
>.  It must be issued or the server
 will get <SPAN
CLASS="QUOTE"
>"out of sync"</SPAN
> with  the client.   Upon
 return from this function, the server is ready to
 receive the next SQL command.
 The return value is 0  on  successful  completion,
 nonzero otherwise.  (Use <CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
> to retrieve
 details if the return value is nonzero.)</P
><P
>When using <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>, the application should respond to
a <VAR
CLASS="LITERAL"
>PGRES_COPY_OUT</VAR
> result by executing <CODE
CLASS="FUNCTION"
>PQgetline</CODE
>
repeatedly, followed by <CODE
CLASS="FUNCTION"
>PQendcopy</CODE
> after the terminator line is seen.
It should then return to the <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> loop until
<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> returns a null pointer. Similarly a <VAR
CLASS="LITERAL"
>PGRES_COPY_IN</VAR
>
result is processed by a series of <CODE
CLASS="FUNCTION"
>PQputline</CODE
> calls followed by
<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>, then return to the <CODE
CLASS="FUNCTION"
>PQgetResult</CODE
> loop.
This arrangement will ensure that
a <TT
CLASS="COMMAND"
>COPY</TT
> command embedded in a series of <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> commands
will be executed correctly.</P
><P
>Older applications are likely to submit a <TT
CLASS="COMMAND"
>COPY</TT
>
via <CODE
CLASS="FUNCTION"
>PQexec</CODE
> and assume that the transaction is done after
<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>.
This will work correctly only if the <TT
CLASS="COMMAND"
>COPY</TT
> is the only
<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> command in the command string.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-notify.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-control.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Asynchronous Notification</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Control Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>