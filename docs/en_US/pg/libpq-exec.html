<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>27.3. Command Execution Functions</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.1devel Documentation">
<link rel="up" href="libpq.html" title="Chapter 27. libpq - C Library">
<link rel="previous" href="libpq-status.html" title="27.2. Connection Status Functions">
<link rel="next" href="libpq-async.html" title="27.4. Asynchronous Command Processing">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="libpq-exec"></a>27.3. Command Execution Functions</h2></div></div>
<div></div>
</div>
<p>Once a connection to a database server has been successfully
established, the functions described here are used to perform
SQL queries and commands.</p>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="libpq-exec-main"></a>27.3.1. Main Functions</h3></div></div>
<div></div>
</div>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQexec</tt><a name="id2609332"></a></span></dt>
<dd>
<p>          Submits a command to the server
          and waits for the result.
</p>
<pre class="synopsis">PGresult *PQexec(PGconn *conn, const char *command);</pre>
<p>          Returns a <tt class="structname">PGresult</tt> pointer or possibly a null pointer.
          A non-null pointer will generally be returned except in
          out-of-memory conditions or serious errors such as inability
          to send the command to the server.
          If a null pointer is returned, it
          should be treated like a <tt class="symbol">PGRES_FATAL_ERROR</tt> result.
          Use <tt class="function">PQerrorMessage</tt> to get more information
          about such errors.</p>
</dd>
</dl></div>
<p>

It is allowed to include multiple SQL commands (separated by semicolons) in
the command string.  Multiple queries sent in a single <tt class="function">PQexec</tt>
call are processed in a single transaction, unless there are explicit
<tt class="command">BEGIN</tt>/<tt class="command">COMMIT</tt> commands included in the query string to divide it into multiple
transactions.  Note however that the returned <tt class="structname">PGresult</tt>
structure describes only the result of the last command executed from the
string.  Should one of the commands fail, processing of the string stops with
it and the returned <tt class="structname">PGresult</tt> describes the error
condition.</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQexecParams</tt><a name="id2609414"></a></span></dt>
<dd>
<p>          Submits a command to the server and waits for the result,
          with the ability to pass parameters separately from the SQL
          command text.
</p>
<pre class="synopsis">PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);</pre>
<p><tt class="function">PQexecParams</tt> is like <tt class="function">PQexec</tt>, but offers additional
functionality: parameter values can be specified separately from the command
string proper, and query results can be requested in either text or binary
format.  <tt class="function">PQexecParams</tt> is supported only in protocol 3.0 and later
connections; it will fail when using protocol 2.0.</p>
<p>If parameters are used, they are referred to in the command string
as <tt class="literal">$1</tt>, <tt class="literal">$2</tt>, etc.
<i class="parameter"><tt>nParams</tt></i> is the number of parameters supplied; it is the length
of the arrays <i class="parameter"><tt>paramTypes[]</tt></i>, <i class="parameter"><tt>paramValues[]</tt></i>,
<i class="parameter"><tt>paramLengths[]</tt></i>, and <i class="parameter"><tt>paramFormats[]</tt></i>.  (The
array pointers may be <tt class="symbol">NULL</tt> when <i class="parameter"><tt>nParams</tt></i> is zero.)
<i class="parameter"><tt>paramTypes[]</tt></i> specifies, by OID, the data types to be assigned to
the parameter symbols.  If <i class="parameter"><tt>paramTypes</tt></i> is <tt class="symbol">NULL</tt>, or any particular
element in the array is zero, the server assigns a data type to the parameter
symbol in the same way it would do for an untyped literal string.
<i class="parameter"><tt>paramValues[]</tt></i> specifies the actual values of the parameters.
A null pointer in this array means the corresponding parameter is null;
otherwise the pointer points to a zero-terminated text string (for text
format) or binary data in the format expected by the server (for binary
format).
<i class="parameter"><tt>paramLengths[]</tt></i> specifies the actual data lengths of
binary-format parameters.  It is ignored for null parameters and text-format
parameters.  The array pointer may be null when there are no binary
parameters.
<i class="parameter"><tt>paramFormats[]</tt></i> specifies whether parameters are text (put a zero
in the array) or binary (put a one in the array).  If the array pointer is
null then all parameters are presumed to be text.
<i class="parameter"><tt>resultFormat</tt></i> is zero to obtain results in text format, or one to
obtain results in binary format.  (There is not currently a provision to
obtain different result columns in different formats, although that is
possible in the underlying protocol.)</p>
</dd>
</dl></div>
<p>

The primary advantage of <tt class="function">PQexecParams</tt> over <tt class="function">PQexec</tt>
is that parameter values may be separated from the command string, thus
avoiding the need for tedious and error-prone quoting and escaping.

Unlike <tt class="function">PQexec</tt>, <tt class="function">PQexecParams</tt> allows at most one SQL
command in the given string.  (There can be semicolons in it, but not more
than one nonempty command.)  This is a limitation of the underlying protocol,
but has some usefulness as an extra defense against SQL-injection attacks.</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQprepare</tt><a name="id2609616"></a></span></dt>
<dd>
<p>          Submits a request to create a prepared statement with the
          given parameters, and waits for completion.
</p>
<pre class="synopsis">PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);</pre>
<p><tt class="function">PQprepare</tt> creates a prepared statement for later execution with
<tt class="function">PQexecPrepared</tt>.
This feature allows commands
that will be used repeatedly to be parsed and planned just once, rather
than each time they are executed.
<tt class="function">PQprepare</tt> is supported only in protocol 3.0 and later
connections; it will fail when using protocol 2.0.</p>
<p>The function creates a prepared statement named <i class="parameter"><tt>stmtName</tt></i>
from the <i class="parameter"><tt>query</tt></i> string, which must contain a single SQL command.
<i class="parameter"><tt>stmtName</tt></i> may be <tt class="literal">""</tt> to create an unnamed statement,
in which case any pre-existing unnamed statement is automatically replaced;
otherwise it is an error if the statement name is already defined in the
current session.
If any parameters are used, they are referred
to in the query as <tt class="literal">$1</tt>, <tt class="literal">$2</tt>, etc.
<i class="parameter"><tt>nParams</tt></i> is the number of parameters for which types are
pre-specified in the array <i class="parameter"><tt>paramTypes[]</tt></i>.  (The array pointer
may be <tt class="symbol">NULL</tt> when <i class="parameter"><tt>nParams</tt></i> is zero.)
<i class="parameter"><tt>paramTypes[]</tt></i> specifies, by OID, the data types to be assigned to
the parameter symbols.  If <i class="parameter"><tt>paramTypes</tt></i> is <tt class="symbol">NULL</tt>,
or any particular element in the array is zero, the server assigns a data type
to the parameter symbol in the same way it would do for an untyped literal
string.  Also, the query may use parameter symbols with numbers higher than
<i class="parameter"><tt>nParams</tt></i>; data types will be inferred for these symbols as
well.</p>
<p>As with <tt class="function">PQexec</tt>, the result is normally a
<tt class="structname">PGresult</tt> object whose contents indicate server-side
success or failure.  A null result indicates out-of-memory or inability to
send the command at all.
Use <tt class="function">PQerrorMessage</tt> to get more information
about such errors.</p>
<p>At present, there is no way to determine the actual data type inferred for
any parameters whose types are not specified in <i class="parameter"><tt>paramTypes[]</tt></i>.
This is a <span class="application">libpq</span> omission that will probably be rectified
in a future release.</p>
</dd>
</dl></div>
<p>

Prepared statements for use with <tt class="function">PQexecPrepared</tt> can also be
created by executing SQL <tt class="command">PREPARE</tt> statements.  (But
<tt class="function">PQprepare</tt> is more flexible since it does not require
parameter types to be pre-specified.)  Also, although there is no
<span class="application">libpq</span> function for deleting a prepared statement,
the SQL <tt class="command">DEALLOCATE</tt> statement can be used for that purpose.</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQexecPrepared</tt><a name="id2609836"></a></span></dt>
<dd>
<p>          Sends a request to execute a prepared statement with given
          parameters, and waits for the result.
</p>
<pre class="synopsis">PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);</pre>
<p><tt class="function">PQexecPrepared</tt> is like <tt class="function">PQexecParams</tt>, but the
command to be executed is specified by naming a previously-prepared
statement, instead of giving a query string.
This feature allows commands
that will be used repeatedly to be parsed and planned just once, rather
than each time they are executed.
The statement must have been prepared previously in the current session.
<tt class="function">PQexecPrepared</tt> is supported only in protocol 3.0 and later
connections; it will fail when using protocol 2.0.</p>
<p>The parameters are identical to <tt class="function">PQexecParams</tt>, except that the
name of a prepared statement is given instead of a query string, and the
<i class="parameter"><tt>paramTypes[]</tt></i> parameter is not present (it is not needed since
the prepared statement's parameter types were determined when it was created).</p>
</dd>
</dl></div>
<p>The
<tt class="structname">PGresult</tt><a name="id2609906"></a>
structure encapsulates the result returned by the server.
<span class="application">libpq</span> application programmers should be
careful to maintain the <tt class="structname">PGresult</tt> abstraction.
Use the accessor functions below to get at the contents of
<tt class="structname">PGresult</tt>.  Avoid directly referencing the
fields of the <tt class="structname">PGresult</tt> structure because they
are subject to change in the future.

</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQresultStatus</tt><a name="id2609943"></a></span></dt>
<dd>
<p>          Returns the result status of the command.
</p>
<pre class="synopsis">ExecStatusType PQresultStatus(const PGresult *res);</pre>
<p><tt class="function">PQresultStatus</tt> can return one of the following values:

</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="literal">PGRES_EMPTY_QUERY</tt></span></dt>
<dd><p>The string sent to the server was empty.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_COMMAND_OK</tt></span></dt>
<dd><p>Successful completion of a command returning no data.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_TUPLES_OK</tt></span></dt>
<dd><p>Successful completion of a command returning data (such as
   a <tt class="command">SELECT</tt> or <tt class="command">SHOW</tt>).</p></dd>
<dt><span class="term"><tt class="literal">PGRES_COPY_OUT</tt></span></dt>
<dd><p>Copy Out (from server) data transfer started.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_COPY_IN</tt></span></dt>
<dd><p>Copy In (to server) data transfer started.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_BAD_RESPONSE</tt></span></dt>
<dd><p>The server's response was not understood.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_NONFATAL_ERROR</tt></span></dt>
<dd><p>A nonfatal error (a notice or warning) occurred.</p></dd>
<dt><span class="term"><tt class="literal">PGRES_FATAL_ERROR</tt></span></dt>
<dd><p>A fatal error occurred.</p></dd>
</dl></div>
<p>

If the result status is <tt class="literal">PGRES_TUPLES_OK</tt>, then the
functions described below can be used to retrieve the rows returned by
the query.  Note that a <tt class="command">SELECT</tt> command that happens
to retrieve zero rows still shows <tt class="literal">PGRES_TUPLES_OK</tt>.
<tt class="literal">PGRES_COMMAND_OK</tt> is for commands that can never
return rows (<tt class="command">INSERT</tt>, <tt class="command">UPDATE</tt>,
etc.). A response of <tt class="literal">PGRES_EMPTY_QUERY</tt> may indicate
a bug in the client software.</p>
<p>A result of status <tt class="symbol">PGRES_NONFATAL_ERROR</tt> will never be
returned directly by <tt class="function">PQexec</tt> or other query
execution functions; results of this kind are instead passed to the notice
processor (see <a href="libpq-notice-processing.html" title="27.10. Notice Processing">Section 27.10, &#8220;Notice Processing&#8221;</a>).</p>
</dd>
<dt><span class="term"><tt class="function">PQresStatus</tt><a name="id2610144"></a></span></dt>
<dd>
<p>        Converts the enumerated type returned by <tt class="function">PQresultStatus</tt> into
        a string constant describing the status code. The caller should not 
        free the result.
</p>
<pre class="synopsis">char *PQresStatus(ExecStatusType status);</pre>
</dd>
<dt><span class="term"><tt class="function">PQresultErrorMessage</tt><a name="id2610174"></a></span></dt>
<dd>
<p>Returns the error message associated with the command, or an empty string
if there was no error.
</p>
<pre class="synopsis">char *PQresultErrorMessage(const PGresult *res);</pre>
<p>
If there was an error, the returned string will include a trailing newline. 
The caller should not free the result directly. It will be freed when the 
associated <tt class="structname">PGresult</tt> handle is passed to 
<tt class="function">PQclear</tt>.</p>
<p>Immediately following a <tt class="function">PQexec</tt> or <tt class="function">PQgetResult</tt>
call, <tt class="function">PQerrorMessage</tt> (on the connection) will return the same
string as <tt class="function">PQresultErrorMessage</tt> (on the result).  However, a
<tt class="structname">PGresult</tt> will retain its error message
until destroyed, whereas the connection's error message will change when
subsequent operations are done.  Use <tt class="function">PQresultErrorMessage</tt> when you want to
know the status associated with a particular <tt class="structname">PGresult</tt>; use <tt class="function">PQerrorMessage</tt>
when you want to know the status from the latest operation on the connection.</p>
</dd>
<dt><span class="term"><tt class="function">PQresultErrorField</tt><a name="id2610264"></a></span></dt>
<dd>
<p>Returns an individual field of an error report.
</p>
<pre class="synopsis">char *PQresultErrorField(const PGresult *res, int fieldcode);</pre>
<p>
<i class="parameter"><tt>fieldcode</tt></i> is an error field identifier; see the symbols
listed below.  <tt class="symbol">NULL</tt> is returned if the
<tt class="structname">PGresult</tt> is not an error or warning result,
or does not include the specified field.  Field values will normally
not include a trailing newline. The caller should not free the 
result directly. It will be freed when the
associated <tt class="structname">PGresult</tt> handle is passed to
<tt class="function">PQclear</tt>.</p>
<p>The following field codes are available:
</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="symbol">PG_DIAG_SEVERITY</tt></span></dt>
<dd><p>The severity; the field contents are <tt class="literal">ERROR</tt>,
<tt class="literal">FATAL</tt>, or <tt class="literal">PANIC</tt> (in an error message), or
<tt class="literal">WARNING</tt>, <tt class="literal">NOTICE</tt>, <tt class="literal">DEBUG</tt>,
<tt class="literal">INFO</tt>, or <tt class="literal">LOG</tt> (in a notice message), or a
localized translation of one of these.  Always present.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_SQLSTATE</tt></span></dt>
<dd><p>The SQLSTATE code for the error. The SQLSTATE code identifies the type
of error that has occurred; it can be used by front-end applications
to perform specific operations (such as error handling) in response to
a particular database error. For a list of the possible SQLSTATE
codes, see <a href="errcodes-appendix.html" title="Appendix A. PostgreSQL Error Codes">Appendix A, <i>PostgreSQL Error Codes</i></a>. This field is not
localizable, and is always present.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_MESSAGE_PRIMARY</tt></span></dt>
<dd><p>The primary human-readable error message (typically one line).  Always
present.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_MESSAGE_DETAIL</tt></span></dt>
<dd><p>Detail: an optional secondary error message carrying more detail about
the problem.  May run to multiple lines.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_MESSAGE_HINT</tt></span></dt>
<dd><p>Hint: an optional suggestion what to do about the problem.  This is
intended to differ from detail in that it offers advice (potentially
inappropriate) rather than hard facts.  May run to multiple lines.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_STATEMENT_POSITION</tt></span></dt>
<dd><p>A string containing a decimal integer indicating an error cursor
position as an index into the original statement string.  The first
character has index 1, and positions are measured in characters not
bytes.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_INTERNAL_POSITION</tt></span></dt>
<dd><p>This is defined the same as the <tt class="symbol">PG_DIAG_STATEMENT_POSITION</tt>
field, but it is used when the cursor position refers to an internally
generated command rather than the one submitted by the client.
The <tt class="symbol">PG_DIAG_INTERNAL_QUERY</tt> field will always appear when this field
appears.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_INTERNAL_QUERY</tt></span></dt>
<dd><p>The text of a failed internally-generated command.
This could be, for example, a SQL query issued by a PL/pgSQL function.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_CONTEXT</tt></span></dt>
<dd><p>An indication of the context in which the error occurred.
Presently this includes a call stack traceback of active
procedural language functions and internally-generated queries.
The trace is one entry per line, most recent first.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_SOURCE_FILE</tt></span></dt>
<dd><p>The file name of the source-code location where the error was
reported.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_SOURCE_LINE</tt></span></dt>
<dd><p>The line number of the source-code location where the error was
reported.</p></dd>
<dt><span class="term"><tt class="symbol">PG_DIAG_SOURCE_FUNCTION</tt></span></dt>
<dd><p>The name of the source-code function reporting the error.</p></dd>
</dl></div>
<p>The client is responsible for formatting displayed information to meet
its needs; in particular it should break long lines as needed.
Newline characters appearing in the error message fields should be
treated as paragraph breaks, not line breaks.</p>
<p>Errors generated internally by <span class="application">libpq</span> will
have severity and primary message, but typically no other fields.
Errors returned by a pre-3.0-protocol server will include severity and
primary message, and sometimes a detail message, but no other fields.</p>
<p>Note that error fields are only available from
<tt class="structname">PGresult</tt> objects, not
<tt class="structname">PGconn</tt> objects; there is no
<tt class="function">PQerrorField</tt> function.</p>
</dd>
<dt><span class="term"><tt class="function">PQclear</tt><a name="id2610552"></a></span></dt>
<dd>
<p>          Frees  the  storage  associated with a <tt class="structname">PGresult</tt>.
          Every command result should be freed via <tt class="function">PQclear</tt> when
          it  is  no  longer needed.
</p>
<pre class="synopsis">void PQclear(PGresult *res);</pre>
<p>          You can keep a <tt class="structname">PGresult</tt> object around for as long as you
          need it; it does not go away when you issue a new command,
          nor even if you close the connection.  To get rid of it,
          you must call <tt class="function">PQclear</tt>.  Failure to do this will
          result in memory leaks in your application.</p>
</dd>
<dt><span class="term"><tt class="function">PQmakeEmptyPGresult</tt><a name="id2610602"></a></span></dt>
<dd>
<p>          Constructs an empty <tt class="structname">PGresult</tt> object with the given status.
</p>
<pre class="synopsis">PGresult* PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);</pre>
<p>This is <span class="application">libpq</span>'s internal function to allocate and initialize an empty
<tt class="structname">PGresult</tt> object.  It is exported because some applications find it
useful to generate result objects (particularly objects with error
status) themselves.  If <i class="parameter"><tt>conn</tt></i> is not null and <i class="parameter"><tt>status</tt></i> indicates an error,
the current error message of the specified connection is copied into the <tt class="structname">PGresult</tt>.
Note that <tt class="function">PQclear</tt> should eventually be called on the object, just
as with a <tt class="structname">PGresult</tt> returned by <span class="application">libpq</span> itself.</p>
</dd>
</dl></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="libpq-exec-select-info"></a>27.3.2. Retrieving Query Result Information</h3></div></div>
<div></div>
</div>
<p>These functions are used to extract information from a
<tt class="structname">PGresult</tt> object that represents a successful
query result (that is, one that has status
<tt class="literal">PGRES_TUPLES_OK</tt>).  For objects with other status
values they will act as though the result has zero rows and zero columns.</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQntuples</tt><a name="id2610703"></a></span></dt>
<dd>
<p>          Returns the number of rows (tuples)
          in the query result.
</p>
<pre class="synopsis">int PQntuples(const PGresult *res);</pre>
</dd>
<dt><span class="term"><tt class="function">PQnfields</tt><a name="id2610726"></a></span></dt>
<dd>
<p>          Returns the number of columns (fields)
          in each row of the query result.
</p>
<pre class="synopsis">int PQnfields(const PGresult *res);</pre>
</dd>
<dt><span class="term"><tt class="function">PQfname</tt><a name="id2610748"></a></span></dt>
<dd>
<p>Returns the column name associated with the given column number.
Column numbers start at 0. The caller should not free the result
directly. It will be freed when the associated <tt class="structname">PGresult</tt>
handle is passed to <tt class="function">PQclear</tt>.
</p>
<pre class="synopsis">char *PQfname(const PGresult *res,
              int column_number);</pre>
<p><tt class="symbol">NULL</tt> is returned if the column number is out of range.</p>
</dd>
<dt><span class="term"><tt class="function">PQfnumber</tt><a name="id2610788"></a></span></dt>
<dd>
<p>          Returns the column number associated with the given column name.
</p>
<pre class="synopsis">int PQfnumber(const PGresult *res,
              const char *column_name);</pre>
<p>        -1 is returned if the given name does not match any column.</p>
<p>        The given name is treated like an identifier in an SQL command,
        that is, it is downcased unless double-quoted.  For example,
        given a query result generated from the SQL command
</p>
<pre class="programlisting">select 1 as FOO, 2 as "BAR";</pre>
<p>
        we would have the results:
</p>
<pre class="programlisting">PQfname(res, 0)              <i class="lineannotation"><span class="lineannotation">foo</span></i>
PQfname(res, 1)              <i class="lineannotation"><span class="lineannotation">BAR</span></i>
PQfnumber(res, "FOO")        <i class="lineannotation"><span class="lineannotation">0</span></i>
PQfnumber(res, "foo")        <i class="lineannotation"><span class="lineannotation">0</span></i>
PQfnumber(res, "BAR")        <i class="lineannotation"><span class="lineannotation">-1</span></i>
PQfnumber(res, "\"BAR\"")    <i class="lineannotation"><span class="lineannotation">1</span></i></pre>
</dd>
<dt><span class="term"><tt class="function">PQftable</tt><a name="id2610853"></a></span></dt>
<dd>
<p> Returns the OID of the table from which the given column was fetched.
 Column numbers start at 0.
</p>
<pre class="synopsis">Oid PQftable(const PGresult *res,
             int column_number);</pre>
<p><tt class="literal">InvalidOid</tt> is returned if the column number is out of range,
or if the specified column is not a simple reference to a table column,
or when using pre-3.0 protocol.
You can query the system table <tt class="literal">pg_class</tt> to determine
exactly which table is referenced.</p>
<p>          The type <tt class="type">Oid</tt> and the constant
          <tt class="literal">InvalidOid</tt> will be defined when you include
          the <span class="application">libpq</span> header file. They will
          both be some integer type.</p>
</dd>
<dt><span class="term"><tt class="function">PQftablecol</tt><a name="id2610913"></a></span></dt>
<dd>
<p> Returns the column number (within its table) of the column making up
 the specified query result column.
 Query-result column numbers start at 0, but table columns have nonzero
 numbers.
</p>
<pre class="synopsis">int PQftablecol(const PGresult *res,
                int column_number);</pre>
<p>Zero is returned if the column number is out of range,
or if the specified column is not a simple reference to a table column,
or when using pre-3.0 protocol.</p>
</dd>
<dt><span class="term"><tt class="function">PQfformat</tt><a name="id2610943"></a></span></dt>
<dd>
<p> Returns the format code indicating the format of the given column.
 Column numbers start at 0.
</p>
<pre class="synopsis">int PQfformat(const PGresult *res,
              int column_number);</pre>
<p>Format code zero indicates textual data representation, while format
code one indicates binary representation.  (Other codes are reserved
for future definition.)</p>
</dd>
<dt><span class="term"><tt class="function">PQftype</tt><a name="id2610971"></a></span></dt>
<dd>
<p>          Returns the data type associated with the
          given  column number.  The  integer  returned is the
          internal OID number of the type.  Column numbers start
          at 0.
</p>
<pre class="synopsis">Oid PQftype(const PGresult *res,
            int column_number);</pre>
<p>You can query the system table <tt class="literal">pg_type</tt> to obtain
the names and properties of the various data types. The <span class="acronym">OID</span>s
of the built-in data types are defined in the file <tt class="filename">src/include/catalog/pg_type.h</tt>
in the source tree.</p>
</dd>
<dt><span class="term"><tt class="function">PQfmod</tt><a name="id2611017"></a></span></dt>
<dd>
<p>          Returns  the type modifier of the column
          associated with the given column number.
          Column numbers start at 0.
</p>
<pre class="synopsis">int PQfmod(const PGresult *res,
           int column_number);</pre>
<p>The interpretation of modifier values is type-specific; they typically
indicate precision or size limits.  The value -1 is used to indicate
&#8220;<span class="quote">no information available</span>&#8221;.  Most data types do not use modifiers,
in which case the value is always -1.</p>
</dd>
<dt><span class="term"><tt class="function">PQfsize</tt><a name="id2611051"></a></span></dt>
<dd>
<p>          Returns  the  size  in bytes of the column
          associated with the given column number.
          Column numbers start at 0.
</p>
<pre class="synopsis">int PQfsize(const PGresult *res,
            int column_number);</pre>
<p><tt class="function">PQfsize</tt> returns the space allocated for this column in a database
row, in other words the size of the server's internal representation
of the data type.  (Accordingly, it is not really very useful to clients.)
A negative value indicates the data type is variable-length.</p>
</dd>
<dt><span class="term"><tt class="function">PQbinaryTuples</tt><a name="id2611086"></a></span></dt>
<dd>
<p>Returns 1 if the <tt class="structname">PGresult</tt> contains binary data
and 0 if it contains text data.
</p>
<pre class="synopsis">int PQbinaryTuples(const PGresult *res);</pre>
<p>This function is deprecated (except for its use in connection with
<tt class="command">COPY</tt>), because it is possible for a single
<tt class="structname">PGresult</tt>
to contain text data in some columns and binary data in others.
<tt class="function">PQfformat</tt> is preferred.  <tt class="function">PQbinaryTuples</tt>
returns 1 only if all columns of the result are binary (format 1).</p>
</dd>
<dt><span class="term"><tt class="function">PQgetvalue</tt><a name="id2611140"></a></span></dt>
<dd>
<p>            Returns a single field value of one row of a
            <tt class="structname">PGresult</tt>.  Row and column numbers
            start at 0.  The caller should not free the result
            directly.  It will be freed when the associated
            <tt class="structname">PGresult</tt> handle is passed to
            <tt class="function">PQclear</tt>.
</p>
<pre class="synopsis">char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);</pre>
<p>For data in text format, the value returned by <tt class="function">PQgetvalue</tt>
is a null-terminated character string  representation
of the field value.  For data in binary format, the value is in the binary
representation determined by the data type's <tt class="function">typsend</tt> and
<tt class="function">typreceive</tt> functions.  (The value is actually followed by
a zero byte in this case too, but that is not ordinarily useful, since
the value is likely to contain embedded nulls.)</p>
<p>An empty string is returned if the field value is null.  See
<tt class="function">PQgetisnull</tt> to distinguish null values from empty-string values.</p>
<p>The pointer
returned  by  <tt class="function">PQgetvalue</tt> points to storage that is
part of the <tt class="structname">PGresult</tt> structure.  One should not modify the data it points to,
and one must explicitly 
copy the data into other storage if it is to
be used past the lifetime of the  <tt class="structname">PGresult</tt>  structure itself.</p>
</dd>
<dt><span class="term"><tt class="function">PQgetisnull</tt><a name="id2611236"></a></span></dt>
<dd>
<p>           Tests a field for a null value.
           Row and column numbers start at 0.
</p>
<pre class="synopsis">int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);</pre>
<p>This function returns  1 if the field is null and 0 if
it contains a non-null value.  (Note that <tt class="function">PQgetvalue</tt>
will return an empty string, not a null pointer, for a null field.)</p>
</dd>
<dt><span class="term"><tt class="function">PQgetlength</tt><a name="id2611281"></a></span></dt>
<dd>
<p>          Returns the actual length of a field value in bytes.
          Row and column numbers start at 0.
</p>
<pre class="synopsis">int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);</pre>
<p>This is the actual data length for the particular data value, that is, the
size of the object pointed to by <tt class="function">PQgetvalue</tt>.  For text
data format this is the same as <tt class="function">strlen()</tt>.  For binary format
this is essential information.  Note that one should <span class="emphasis"><em>not</em></span> rely
on <tt class="function">PQfsize</tt> to obtain the actual data length.</p>
</dd>
<dt><span class="term"><tt class="function">PQprint</tt><a name="id2611333"></a></span></dt>
<dd>
<p>          Prints out all the rows and,  optionally,  the
          column names  to  the specified output stream.
</p>
<pre class="synopsis">void PQprint(FILE *fout,      /* output stream */
             const PGresult *res,
             const PQprintOpt *po);

typedef struct {
    pqbool  header;      /* print output field headings and row count */
    pqbool  align;       /* fill align the fields */
    pqbool  standard;    /* old brain dead format */
    pqbool  html3;       /* output HTML tables */
    pqbool  expanded;    /* expand tables */
    pqbool  pager;       /* use pager for output if needed */
    char    *fieldSep;   /* field separator */
    char    *tableOpt;   /* attributes for HTML table element */
    char    *caption;    /* HTML table caption */
    char    **fieldName; /* null-terminated array of replacement field names */
} PQprintOpt;</pre>
<p>This function was formerly used by <span class="application">psql</span>
to print query results, but this is no longer the case.  Note that it
assumes all the data is in text format.</p>
</dd>
</dl></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="libpq-exec-nonselect"></a>27.3.3. Retrieving Result Information for Other Commands</h3></div></div>
<div></div>
</div>
<p>These functions are used to extract information from
<tt class="structname">PGresult</tt> objects that are not <tt class="command">SELECT</tt>
results.</p>
<div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQcmdStatus</tt><a name="id2611401"></a></span></dt>
<dd>
<p>          Returns the command status tag from the SQL command that
          generated the <tt class="structname">PGresult</tt>.
</p>
<pre class="synopsis">char *PQcmdStatus(PGresult *res);</pre>
<p>Commonly this is just the name of the command, but it may include additional
data such as the number of rows processed. The caller should
not free the result directly. It will be freed when the
associated <tt class="structname">PGresult</tt> handle is passed to
<tt class="function">PQclear</tt>.</p>
</dd>
<dt><span class="term"><tt class="function">PQcmdTuples</tt><a name="id2611442"></a></span></dt>
<dd>
<p>          Returns the number of rows affected by the SQL command.
</p>
<pre class="synopsis">char *PQcmdTuples(PGresult *res);</pre>
<p>          This function returns a string containing the number of rows
          affected by the <span class="acronym">SQL</span> statement that generated the
          <tt class="structname">PGresult</tt>. This function can only be used
          following the execution of an <tt class="command">INSERT</tt>,
          <tt class="command">UPDATE</tt>, <tt class="command">DELETE</tt>, <tt class="command">MOVE</tt>, or
          <tt class="command">FETCH</tt> statement, or an <tt class="command">EXECUTE</tt> of a
          prepared query that contains a <tt class="command">INSERT</tt>,
          <tt class="command">UPDATE</tt>, or <tt class="command">DELETE</tt> statement.  If the
          command that generated the <tt class="structname">PGresult</tt> was
          anything else, <tt class="function">PQcmdTuples</tt> returns the empty
          string. The caller should not free the return value
          directly. It will be freed when the associated
          <tt class="structname">PGresult</tt> handle is passed to
          <tt class="function">PQclear</tt>.</p>
</dd>
<dt><span class="term"><tt class="function">PQoidValue</tt><a name="id2611555"></a></span></dt>
<dd>
<p>          Returns the OID<a name="id2611564"></a> of the inserted row, if the <span class="acronym">SQL</span>
          command was an <tt class="command">INSERT</tt> that inserted exactly one
          row into a table that has OIDs, or a <tt class="command">EXECUTE</tt> of
          a prepared query containing a suitable <tt class="command">INSERT</tt>
          statement.  Otherwise, this function returns
          <tt class="literal">InvalidOid</tt>. This function will also
          return <tt class="literal">InvalidOid</tt> if the table affected
          by the <tt class="command">INSERT</tt> statement does not contain OIDs.
</p>
<pre class="synopsis">Oid PQoidValue(const PGresult *res);</pre>
</dd>
<dt><span class="term"><tt class="function">PQoidStatus</tt><a name="id2611630"></a></span></dt>
<dd>
<p>          Returns a string with the OID of the inserted row, if the
          <span class="acronym">SQL</span> command was an
          <tt class="command">INSERT</tt> that inserted exactly one row, or
          a <tt class="command">EXECUTE</tt> of a prepared statement
          consisting of a suitable <tt class="command">INSERT</tt>.  (The string will be
          <tt class="literal">0</tt> if the <tt class="command">INSERT</tt> did not
          insert exactly one row, or if the target table does not have
          OIDs.)  If the command was not an <tt class="command">INSERT</tt>,
          returns an empty string.
</p>
<pre class="synopsis">char *PQoidStatus(const PGresult *res);</pre>
<p>This function is deprecated in favor of <tt class="function">PQoidValue</tt>.
It is not thread-safe.</p>
</dd>
</dl></div>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="libpq-exec-escape-string"></a>27.3.4. Escaping Strings for Inclusion in SQL Commands</h3></div></div>
<div></div>
</div>
<a name="id2611708"></a><a name="id2611720"></a><p><tt class="function">PQescapeString</tt> escapes a string for use within an SQL
command.  This is useful when inserting data values as literal constants
in SQL commands.  Certain characters (such as quotes and backslashes) must
be escaped to prevent them from being interpreted specially by the SQL parser.
<tt class="function">PQescapeString</tt> performs this operation.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Tip</h3>
<p>It is especially important to do proper escaping when handling strings that
were received from an untrustworthy source.  Otherwise there is a security
risk: you are vulnerable to &#8220;<span class="quote">SQL injection</span>&#8221; attacks wherein unwanted
SQL commands are fed to your database.</p>
</div>
<p>Note that it is not necessary nor correct to do escaping when a data
value is passed as a separate parameter in <tt class="function">PQexecParams</tt> or
its sibling routines.

</p>
<pre class="synopsis">size_t PQescapeString (char *to, const char *from, size_t length);</pre>
<p>The parameter <i class="parameter"><tt>from</tt></i> points to the first character of the string
that is to be escaped, and the <i class="parameter"><tt>length</tt></i> parameter gives the
number of characters in this string.  A terminating zero byte is not
required, and should not be counted in <i class="parameter"><tt>length</tt></i>.  (If
a terminating zero byte is found before <i class="parameter"><tt>length</tt></i> bytes are
processed, <tt class="function">PQescapeString</tt> stops at the zero; the behavior
is thus rather like <tt class="function">strncpy</tt>.)
<i class="parameter"><tt>to</tt></i> shall point to a
buffer that is able to hold at least one more character than twice
the value of <i class="parameter"><tt>length</tt></i>, otherwise the behavior is
undefined.  A call to <tt class="function">PQescapeString</tt> writes an escaped
version of the <i class="parameter"><tt>from</tt></i> string to the <i class="parameter"><tt>to</tt></i>
buffer, replacing special characters so that they cannot cause any
harm, and adding a terminating zero byte.  The single quotes that
must surround <span class="productname">PostgreSQL</span> string literals are not
included in the result string; they should be provided in the SQL
command that the result is inserted into.</p>
<p><tt class="function">PQescapeString</tt> returns the number of characters written
to <i class="parameter"><tt>to</tt></i>, not including the terminating zero byte.</p>
<p>Behavior is undefined if the <i class="parameter"><tt>to</tt></i> and <i class="parameter"><tt>from</tt></i>
strings overlap.</p>
</div>
<div class="sect2" lang="en">
<div class="titlepage">
<div><div><h3 class="title">
<a name="libpq-exec-escape-bytea"></a>27.3.5. Escaping Binary Strings for Inclusion in SQL Commands</h3></div></div>
<div></div>
</div>
<a name="id2611899"></a><div class="variablelist"><dl>
<dt><span class="term"><tt class="function">PQescapeBytea</tt><a name="id2611922"></a></span></dt>
<dd>
<p>   Escapes binary data for use within an SQL command with the type
   <tt class="type">bytea</tt>.  As with <tt class="function">PQescapeString</tt>,
   this is only used when inserting data directly into an SQL command string.
</p>
<pre class="synopsis">unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);</pre>
<p>   Certain byte values <span class="emphasis"><em>must</em></span> be escaped (but all
   byte values <span class="emphasis"><em>may</em></span> be escaped) when used as part
   of a <tt class="type">bytea</tt> literal in an <span class="acronym">SQL</span>
   statement. In general, to escape a byte, it is converted into the
   three digit octal number equal to the octet value, and preceded by
   two backslashes. The single quote (<tt class="literal">'</tt>) and backslash
   (<tt class="literal">\</tt>) characters have special alternative escape
   sequences. See <a href="datatype-binary.html" title="8.4. Binary Data Types">Section 8.4, &#8220;Binary Data Types&#8221;</a> for more
   information. <tt class="function">PQescapeBytea</tt> performs this
   operation, escaping only the minimally required bytes.
  </p>
<p>   The <i class="parameter"><tt>from</tt></i> parameter points to the first
   byte of the string that is to be escaped, and the
   <i class="parameter"><tt>from_length</tt></i> parameter gives the number of
   bytes in this binary string.  (A terminating zero byte is
   neither necessary nor counted.)  The <i class="parameter"><tt>to_length</tt></i>
   parameter points to a variable that will hold the resultant
   escaped string length. The result string length includes the terminating
   zero byte of the result.
  </p>
<p>   <tt class="function">PQescapeBytea</tt> returns an escaped version of the
   <i class="parameter"><tt>from</tt></i> parameter binary string in memory
   allocated with <tt class="function">malloc()</tt>.  This memory must be freed
   using <tt class="function">PQfreemem</tt> when the result is no longer needed.
   The return string has all special characters replaced so that they
   can be properly processed by the
   <span class="productname">PostgreSQL</span> string literal parser, and
   the <tt class="type">bytea</tt> input function. A terminating zero byte is
   also added.  The single quotes that must surround
   <span class="productname">PostgreSQL</span> string literals are not part
   of the result string.
  </p>
</dd>
<dt><span class="term"><tt class="function">PQunescapeBytea</tt><a name="id2612080"></a></span></dt>
<dd>
<p>   Converts an escaped string representation of binary data into binary
   data [mdash ] the reverse of <tt class="function">PQescapeBytea</tt>.
   This is needed when retrieving <tt class="type">bytea</tt> data in text format,
   but not when retrieving it in binary format.

</p>
<pre class="synopsis">unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);</pre>
<p>   The <i class="parameter"><tt>from</tt></i> parameter points to an escaped string
   such as might be returned by <tt class="function">PQgetvalue</tt> when applied to a
   <tt class="type">bytea</tt> column. <tt class="function">PQunescapeBytea</tt> converts
   this string representation into its binary representation.
   It returns a pointer to a buffer allocated with
   <tt class="function">malloc()</tt>, or null on error, and puts the size of
   the buffer in <i class="parameter"><tt>to_length</tt></i>. The result must be
   freed using <tt class="function">PQfreemem</tt> when it is no longer needed.
  </p>
</dd>
<dt><span class="term"><tt class="function">PQfreemem</tt><a name="id2612163"></a></span></dt>
<dd>
<p>   Frees memory allocated by <span class="application">libpq</span>.
</p>
<pre class="synopsis">void PQfreemem(void *ptr);</pre>
<p>   Frees memory allocated by <span class="application">libpq</span>, particularly
   <tt class="function">PQescapeBytea</tt>,
   <tt class="function">PQunescapeBytea</tt>,
   and <tt class="function">PQnotifies</tt>.
   It is needed by Microsoft Windows, which cannot free memory across
   DLLs, unless multithreaded DLLs (<tt class="option">/MD</tt> in VC6) are used.
   On other platforms, this function is the same as the standard library function <tt class="function">free()</tt>.
  </p>
</dd>
</dl></div>
</div>
</div></body>
</html>
