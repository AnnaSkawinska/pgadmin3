<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>11.2. Index Types</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.2 Documentation">
<link rel="up" href="indexes.html" title="Chapter 11. Indexes">
<link rel="previous" href="indexes.html" title="Chapter 11. Indexes">
<link rel="next" href="indexes-multicolumn.html" title="11.3. Multicolumn Indexes">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="indexes-types"></a>11.2. Index Types</h2></div></div>
<div></div>
</div>
<p>   <span class="productname">PostgreSQL</span> provides several index types:
   B-tree, R-tree, Hash, and GiST.  Each index type uses a different
   algorithm that is best suited to different types of queries.
   By default, the <tt class="command">CREATE INDEX</tt> command will create a
   B-tree index, which fits the most common situations.
  </p>
<p>   <a name="id2568922"></a>
   <a name="id2568931"></a>
   B-trees can handle equality and range queries on data that can be sorted
   into some ordering.
   In particular, the <span class="productname">PostgreSQL</span> query planner
   will consider using a B-tree index whenever an indexed column is
   involved in a comparison using one of these operators:

   </p>
<table class="simplelist" border="0" summary="Simple list">
<tr><td><tt class="literal">&lt;</tt></td></tr>
<tr><td><tt class="literal">&lt;=</tt></td></tr>
<tr><td><tt class="literal">=</tt></td></tr>
<tr><td><tt class="literal">&gt;=</tt></td></tr>
<tr><td><tt class="literal">&gt;</tt></td></tr>
</table>
<p>

   Constructs equivalent to combinations of these operators, such as
   <tt class="literal">BETWEEN</tt> and <tt class="literal">IN</tt>, can also be implemented with
   a B-tree index search.  (But note that <tt class="literal">IS NULL</tt> is not
   equivalent to <tt class="literal">=</tt> and is not indexable.)
  </p>
<p>   The optimizer can also use a B-tree index for queries involving the
   pattern matching operators <tt class="literal">LIKE</tt>,
   <tt class="literal">ILIKE</tt>, <tt class="literal">~</tt>, and
   <tt class="literal">~*</tt>, <span class="emphasis"><em>if</em></span> the pattern is
   anchored to the beginning of the string, e.g., <tt class="literal">col LIKE
   'foo%'</tt> or <tt class="literal">col ~ '^foo'</tt>, but not
   <tt class="literal">col LIKE '%bar'</tt>.  However, if your server does
   not use the C locale you will need to create the index with a
   special operator class to support indexing of pattern-matching queries.
   See <a href="indexes-opclass.html" title="11.6. Operator Classes">Section 11.6, &#8220;Operator Classes&#8221;</a> below.
  </p>
<p>   <a name="id2569073"></a>
   <a name="id2569082"></a>
   R-tree indexes are suited for queries on spatial data.  To create
   an R-tree index, use a command of the form
</p>
<pre class="synopsis">CREATE INDEX <i class="replaceable"><tt>name</tt></i> ON <i class="replaceable"><tt>table</tt></i> USING RTREE (<i class="replaceable"><tt>column</tt></i>);</pre>
<p>
   The <span class="productname">PostgreSQL</span> query planner will
   consider using an R-tree index whenever an indexed column is
   involved in a comparison using one of these operators:

   </p>
<table class="simplelist" border="0" summary="Simple list">
<tr><td><tt class="literal">&lt;&lt;</tt></td></tr>
<tr><td><tt class="literal">&amp;&lt;</tt></td></tr>
<tr><td><tt class="literal">&amp;&gt;</tt></td></tr>
<tr><td><tt class="literal">&gt;&gt;</tt></td></tr>
<tr><td><tt class="literal">@</tt></td></tr>
<tr><td><tt class="literal">~=</tt></td></tr>
<tr><td><tt class="literal">&amp;&amp;</tt></td></tr>
</table>
<p>

   (See <a href="functions-geometry.html" title="9.10. Geometric Functions and Operators">Section 9.10, &#8220;Geometric Functions and Operators&#8221;</a> for the meaning of
   these operators.)
  </p>
<p>   <a name="id2569172"></a>
   <a name="id2569181"></a>
   Hash indexes can only handle simple equality comparisons.
   The query planner will consider using a hash index whenever an
   indexed column is involved in a comparison using the
   <tt class="literal">=</tt> operator.  The following command is used to
   create a hash index:
</p>
<pre class="synopsis">CREATE INDEX <i class="replaceable"><tt>name</tt></i> ON <i class="replaceable"><tt>table</tt></i> USING HASH (<i class="replaceable"><tt>column</tt></i>);</pre>
<p>
   </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>     Testing has shown <span class="productname">PostgreSQL</span>'s hash
     indexes to perform no better than B-tree indexes, and the
     index size and build time for hash indexes is much worse. For
     these reasons, hash index use is presently discouraged.
    </p>
</div>
<p>  
  </p>
<p>   GiST indexes are not a single kind of index, but rather an infrastructure
   within which many different indexing strategies can be implemented.
   Accordingly, the particular operators with which a GiST index can be
   used vary depending on the indexing strategy (the <i class="firstterm">operator
   class</i>).  For more information see <a href="gist.html" title="Chapter 48. GiST Indexes">Chapter 48, <i>GiST Indexes</i></a>.
  </p>
<p>   The B-tree index method is an implementation of Lehman-Yao
   high-concurrency B-trees.  The R-tree index method implements
   standard R-trees using Guttman's quadratic split algorithm.  The
   hash index method is an implementation of Litwin's linear hashing.  We
   mention the algorithms used solely to indicate that all of these
   index methods are fully dynamic and do not have to be optimized
   periodically (as is the case with, for example, static hash methods).
  </p>
</div></body>
</html>
