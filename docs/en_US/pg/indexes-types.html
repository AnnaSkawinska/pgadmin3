<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Index Types</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Indexes"
HREF="indexes.html"><LINK
REL="PREVIOUS"
TITLE="Indexes"
HREF="indexes.html"><LINK
REL="NEXT"
TITLE="Multicolumn Indexes"
HREF="indexes-multicolumn.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-10-03T03:19:47"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 11. Indexes</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="indexes.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="indexes-multicolumn.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INDEXES-TYPES"
>11.2. Index Types</A
></H1
><P
>   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> provides several index types:
   B-tree, R-tree, GiST, and Hash.  Each index type is more appropriate for
   a particular query type because of the algorithm it uses.
   <A
NAME="AEN13041"
></A
>
   <A
NAME="AEN13044"
></A
>
   By
   default, the <TT
CLASS="COMMAND"
>CREATE INDEX</TT
> command will create a
   B-tree index, which fits the most common situations.  In
   particular, the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> query planner
   will consider using a B-tree index whenever an indexed column is
   involved in a comparison using one of these operators:

   <VAR
CLASS="LITERAL"
>&lt;</VAR
>, <VAR
CLASS="LITERAL"
>&lt;=</VAR
>, <VAR
CLASS="LITERAL"
>=</VAR
>, <VAR
CLASS="LITERAL"
>&gt;=</VAR
>, <VAR
CLASS="LITERAL"
>&gt;</VAR
>
  </P
><P
>   The optimizer can also use a B-tree index for queries involving the
   pattern matching operators <VAR
CLASS="LITERAL"
>LIKE</VAR
>,
   <VAR
CLASS="LITERAL"
>ILIKE</VAR
>, <VAR
CLASS="LITERAL"
>~</VAR
>, and
   <VAR
CLASS="LITERAL"
>~*</VAR
>, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>if</I
></SPAN
> the pattern is
   anchored to the beginning of the string, e.g., <VAR
CLASS="LITERAL"
>col LIKE
   'foo%'</VAR
> or <VAR
CLASS="LITERAL"
>col ~ '^foo'</VAR
>, but not
   <VAR
CLASS="LITERAL"
>col LIKE '%bar'</VAR
>.  However, if your server does
   not use the C locale you will need to create the index with a
   special operator class.  See <A
HREF="indexes-opclass.html"
>Section 11.6</A
>
   below.
  </P
><P
>   <A
NAME="AEN13071"
></A
>
   <A
NAME="AEN13074"
></A
>
   R-tree indexes are especially suited for spatial data.  To create
   an R-tree index, use a command of the form
</P><PRE
CLASS="SYNOPSIS"
>CREATE INDEX <VAR
CLASS="REPLACEABLE"
>name</VAR
> ON <VAR
CLASS="REPLACEABLE"
>table</VAR
> USING RTREE (<VAR
CLASS="REPLACEABLE"
>column</VAR
>);</PRE
><P>
   The <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> query planner will
   consider using an R-tree index whenever an indexed column is
   involved in a comparison using one of these operators:

   <VAR
CLASS="LITERAL"
>&lt;&lt;</VAR
>, <VAR
CLASS="LITERAL"
>&amp;&lt;</VAR
>, <VAR
CLASS="LITERAL"
>&amp;&gt;</VAR
>, <VAR
CLASS="LITERAL"
>&gt;&gt;</VAR
>, <VAR
CLASS="LITERAL"
>@</VAR
>, <VAR
CLASS="LITERAL"
>~=</VAR
>, <VAR
CLASS="LITERAL"
>&amp;&amp;</VAR
>
   (Refer to <A
HREF="functions-geometry.html"
>Section 9.9</A
> about the meaning of
   these operators.)
  </P
><P
>   <A
NAME="AEN13099"
></A
>
   <A
NAME="AEN13102"
></A
>
   The query planner will consider using a hash index whenever an
   indexed column is involved in a comparison using the
   <VAR
CLASS="LITERAL"
>=</VAR
> operator.  The following command is used to
   create a hash index:
</P><PRE
CLASS="SYNOPSIS"
>CREATE INDEX <VAR
CLASS="REPLACEABLE"
>name</VAR
> ON <VAR
CLASS="REPLACEABLE"
>table</VAR
> USING HASH (<VAR
CLASS="REPLACEABLE"
>column</VAR
>);</PRE
><P>
   </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     Testing has shown <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s hash
     indexes to be similar or slower than B-tree indexes, and the
     index size and build time for hash indexes is much worse. Hash
     indexes also suffer poor performance under high concurrency. For
     these reasons, hash index use is presently discouraged.
    </P
></BLOCKQUOTE
></DIV
><P>  
  </P
><P
>   The B-tree index is an implementation of Lehman-Yao
   high-concurrency B-trees.  The R-tree index method implements
   standard R-trees using Guttman's quadratic split algorithm.  The
   hash index is an implementation of Litwin's linear hashing.  We
   mention the algorithms used solely to indicate that all of these
   index methods are fully dynamic and do not have to be optimized
   periodically (as is the case with, for example, static hash methods).
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="indexes-multicolumn.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Indexes</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Multicolumn Indexes</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>