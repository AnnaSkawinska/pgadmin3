<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapter 37. PL/Perl - Perl Procedural Language</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.2 Documentation">
<link rel="up" href="server-programming.html" title="Part V. Server Programming">
<link rel="previous" href="pltcl-procnames.html" title="36.8. Tcl Procedure Names">
<link rel="next" href="plperl-database.html" title="37.2. Database Access from PL/Perl">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="chapter" lang="en" id="plperl">
<div class="titlepage">
<div><div><h2 class="title">
<a name="plperl"></a>Chapter 37. PL/Perl - Perl Procedural Language</h2></div></div>
<div></div>
</div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="sect1"><a href="plperl.html#plperl-funcs">37.1. PL/Perl Functions and Arguments</a></span></dt>
<dt><span class="sect1"><a href="plperl-database.html">37.2. Database Access from PL/Perl</a></span></dt>
<dt><span class="sect1"><a href="plperl-data.html">37.3. Data Values in PL/Perl</a></span></dt>
<dt><span class="sect1"><a href="plperl-global.html">37.4. Global Values in PL/Perl</a></span></dt>
<dt><span class="sect1"><a href="plperl-trusted.html">37.5. Trusted and Untrusted PL/Perl</a></span></dt>
<dt><span class="sect1"><a href="plperl-triggers.html">37.6. PL/Perl Triggers</a></span></dt>
<dt><span class="sect1"><a href="plperl-missing.html">37.7. Limitations and Missing Features</a></span></dt>
</dl>
</div>
<a name="id2656326"></a><a name="id2656335"></a><p>   PL/Perl is a loadable procedural language that enables you to write
   <span class="productname">PostgreSQL</span> functions in the <a href="http://www.perl.com" target="_top">Perl</a> programming language.
  </p>
<p>   To install PL/Perl in a particular database, use
   <tt class="literal">createlang plperl <i class="replaceable"><tt>dbname</tt></i></tt>.
  </p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Tip</h3>
<p>    If a language is installed into <tt class="literal">template1</tt>, all subsequently
    created databases will have the language installed automatically.
   </p>
</div>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>    Users of source packages must specially enable the build of
    PL/Perl during the installation process.  (Refer to <a href="installation.html#install-short" title="14.1. Short Version">Section 14.1, &#8220;Short Version&#8221;</a> for more information.)  Users of
    binary packages might find PL/Perl in a separate subpackage.
   </p>
</div>
<div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="plperl-funcs"></a>37.1. PL/Perl Functions and Arguments</h2></div></div>
<div></div>
</div>
<p>   To create a function in the PL/Perl language, use the standard syntax:
</p>
<pre class="programlisting">CREATE FUNCTION <i class="replaceable"><tt>funcname</tt></i> (<i class="replaceable"><tt>argument-types</tt></i>) RETURNS <i class="replaceable"><tt>return-type</tt></i> AS $$
    # PL/Perl function body
$$ LANGUAGE plperl;</pre>
<p>
   The body of the function is ordinary Perl code.
  </p>
<p>    The syntax of the <tt class="command">CREATE FUNCTION</tt> command requires
    the function body to be written as a string constant.  It is usually
    most convenient to use dollar quoting (see <a href="sql-syntax.html#sql-syntax-dollar-quoting" title="4.1.2.2. Dollar-Quoted String Constants">Section 4.1.2.2, &#8220;Dollar-Quoted String Constants&#8221;</a>) for the string constant.
    If you choose to use regular single-quoted string constant syntax,
    you must escape single quote marks (<tt class="literal">'</tt>) and backslashes
    (<tt class="literal">\</tt>) used in the body of the function, typically by
    doubling them (see <a href="sql-syntax.html#sql-syntax-strings" title="4.1.2.1. String Constants">Section 4.1.2.1, &#8220;String Constants&#8221;</a>).
   </p>
<p>   Arguments and results are handled as in any other Perl subroutine:
   arguments are passed in <tt class="varname">@_</tt>, and a result value
   is returned with <tt class="literal">return</tt> or as the last expression
   evaluated in the function.
  </p>
<p>   For example, a function returning the greater of two integer values
   could be defined as:

</p>
<pre class="programlisting">CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;</pre>
<p>
  </p>
<p>   If an SQL null value<a name="id2656495"></a> is passed to a function,
   the argument value will appear as &#8220;<span class="quote">undefined</span>&#8221; in Perl.  The
   above function definition will not behave very nicely with null
   inputs (in fact, it will act as though they are zeroes).  We could
   add <tt class="literal">STRICT</tt> to the function definition to make
   <span class="productname">PostgreSQL</span> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically.  Alternatively,
   we could check for undefined inputs in the function body.  For
   example, suppose that we wanted <tt class="function">perl_max</tt> with
   one null and one nonnull argument to return the nonnull argument,
   rather than a null value:

</p>
<pre class="programlisting">CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($a,$b) = @_;
    if (! defined $a) {
        if (! defined $b) { return undef; }
        return $b;
    }
    if (! defined $b) { return $a; }
    if ($a &gt; $b) { return $a; }
    return $b;
$$ LANGUAGE plperl;</pre>
<p>
   As shown above, to return an SQL null value from a PL/Perl
   function, return an undefined value.  This can be done whether the
   function is strict or not.
  </p>
<p>   Composite-type arguments are passed to the function as references
   to hashes.  The keys of the hash are the attribute names of the
   composite type.  Here is an example:

</p>
<pre class="programlisting">CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;</pre>
<p>
  </p>
<p>   A PL/Perl function can return a composite-type result using the same
   approach: return a reference to a hash that has the required attributes.
   For example,

</p>
<pre class="programlisting">CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();</pre>
<p>

   Any columns in the declared result data type that are not present in the
   hash will be returned as NULLs.
  </p>
<p>   PL/Perl functions can also return sets of either scalar or composite
   types.  To do this, return a reference to an array that contains
   either scalars or references to hashes, respectively.  Here are
   some simple examples:

</p>
<pre class="programlisting">CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);


CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$  LANGUAGE plperl;

SELECT * FROM perl_set();</pre>
<p>

   Note that when you do this, Perl will have to build the entire array in
   memory; therefore the technique does not scale to very large result sets.
  </p>
<p>     <span class="application">PL/Perl</span> does not currently have full support for
     domain types: it treats a domain the same as the underlying scalar
     type.  This means that constraints associated with the domain will
     not be enforced.  This is not an issue for function arguments, but
     it is a hazard if you declare a <span class="application">PL/Perl</span> function
     as returning a domain type.
    </p>
</div>
</div></body>
</html>
