<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>5.5. Inheritance</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.1devel Documentation">
<link rel="up" href="ddl.html" title="Chapter 5. Data Definition">
<link rel="previous" href="ddl-system-columns.html" title="5.4. System Columns">
<link rel="next" href="ddl-alter.html" title="5.6. Modifying Tables">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="ddl-inherit"></a>5.5. Inheritance</h2></div></div>
<div></div>
</div>
<i><span class="remark">This section needs to be rethought.  Some of the
  information should go into the following chapters.</span></i><p>   Let's create two tables. The capitals  table  contains
   state  capitals  which  are also cities. Naturally, the
   capitals table should inherit from cities.

</p>
<pre class="programlisting">CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- (in ft)
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);</pre>
<p>

   In this case, a row of capitals <i class="firstterm">inherits</i> all
   attributes (name, population, and altitude) from its parent, cities.  State
   capitals have an extra attribute, state, that shows their state.  In
   <span class="productname">PostgreSQL</span>, a table can inherit from zero or
   more other tables, and a query can reference either all rows of a table or
   all rows of a table plus all of its descendants.

   </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Note</h3>
<p>     The inheritance hierarchy is actually a directed acyclic graph.
    </p>
</div>
<p>
  </p>
<p>    For example, the  following  query finds the  names  of  all  cities,
    including  state capitals, that are located at an altitude 
    over 500ft:

</p>
<pre class="programlisting">SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;</pre>
<p>

   which returns:

</p>
<pre class="programlisting">   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845</pre>
<p>
  </p>
<p>    On the other hand, the  following  query  finds
    all  the cities that are not state capitals and
    are situated at an altitude over 500ft:

</p>
<pre class="programlisting">SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953</pre>
<p>         
  </p>
<p>   Here the &#8220;<span class="quote">ONLY</span>&#8221; before cities indicates that the query should
   be  run over only cities and not tables below cities in the
   inheritance hierarchy.  Many of the  commands  that  we
   have  already discussed -- <tt class="command">SELECT</tt>,
   <tt class="command">UPDATE</tt> and <tt class="command">DELETE</tt> --
   support this &#8220;<span class="quote">ONLY</span>&#8221; notation.
  </p>
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Deprecated</h3>
<p>     In previous versions of <span class="productname">PostgreSQL</span>, the
     default behavior was not to include child tables in queries. This was
     found to be error prone and is also in violation of the SQL:1999
     standard. Under the old syntax, to get the sub-tables you append
     <tt class="literal">*</tt> to the table name.
     For example
</p>
<pre class="programlisting">SELECT * from cities*;</pre>
<p>
     You can still explicitly specify scanning child tables by appending
     <tt class="literal">*</tt>, as well as explicitly specify not scanning child tables by
     writing &#8220;<span class="quote">ONLY</span>&#8221;.  But beginning in version 7.1, the default
     behavior for an undecorated table name is to scan its child tables
     too, whereas before the default was not to do so.  To get the old
     default behavior, set the configuration option
     <tt class="literal">SQL_Inheritance</tt> to off, e.g.,
</p>
<pre class="programlisting">SET SQL_Inheritance TO OFF;</pre>
<p>
     or add a line in your <tt class="filename">postgresql.conf</tt> file.
   </p>
</div>
<p>  In some cases you may wish to know which table a particular row
  originated from. There is a system column called
  <tt class="structfield">tableoid</tt> in each table which can tell you the
  originating table:

</p>
<pre class="programlisting">SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;</pre>
<p>

   which returns:

</p>
<pre class="programlisting"> tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845</pre>
<p>

   (If you try to reproduce this example, you will probably get
   different numeric OIDs.)  By doing a join with
   <tt class="structname">pg_class</tt> you can see the actual table names:

</p>
<pre class="programlisting">SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 and c.tableoid = p.oid;</pre>
<p>

   which returns:

</p>
<pre class="programlisting"> relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845</pre>
<p>
   
  </p>
<p>   A table can inherit from more than one parent table, in which case it has
   the union of the columns defined by the parent tables (plus any columns
   declared specifically for the child table).
  </p>
<p>   A serious limitation of the inheritance feature is that indexes (including
   unique constraints) and foreign key constraints only apply to single
   tables, not to their inheritance children.  This is true on both the
   referencing and referenced sides of a foreign key constraint.  Thus,
   in the terms of the above example:

   </p>
<div class="itemizedlist"><ul type="disc">
<li><p>      If we declared <tt class="structname">cities</tt>.<tt class="structfield">name</tt> to be
      <tt class="literal">UNIQUE</tt> or a <tt class="literal">PRIMARY KEY</tt>, this would not stop the
      <tt class="structname">capitals</tt> table from having rows with names duplicating
      rows in <tt class="structname">cities</tt>.  And those duplicate rows would by
      default show up in queries from <tt class="structname">cities</tt>.  In fact, by
      default <tt class="structname">capitals</tt> would have no unique constraint at all,
      and so could contain multiple rows with the same name.
      You could add a unique constraint to <tt class="structname">capitals</tt>, but this
      would not prevent duplication compared to <tt class="structname">cities</tt>.
     </p></li>
<li><p>      Similarly, if we were to specify that
      <tt class="structname">cities</tt>.<tt class="structfield">name</tt> <tt class="literal">REFERENCES</tt> some
      other table, this constraint would not automatically propagate to
      <tt class="structname">capitals</tt>.  In this case you could work around it by
      manually adding the same <tt class="literal">REFERENCES</tt> constraint to
      <tt class="structname">capitals</tt>.
     </p></li>
<li><p>      Specifying that another table's column <tt class="literal">REFERENCES
      cities(name)</tt> would allow the other table to contain city names, but
      not capital names.  There is no good workaround for this case.
     </p></li>
</ul></div>
<p>

   These deficiencies will probably be fixed in some future release,
   but in the meantime considerable care is needed in deciding whether
   inheritance is useful for your problem.
  </p>
</div></body>
</html>
