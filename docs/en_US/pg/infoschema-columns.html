<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>columns</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="The Information Schema"
HREF="information-schema.html"><LINK
REL="PREVIOUS"
TITLE="column_udt_usage"
HREF="infoschema-column-udt-usage.html"><LINK
REL="NEXT"
TITLE="constraint_column_usage"
HREF="infoschema-constraint-column-usage.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-11-16T21:52:34"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="infoschema-column-udt-usage.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="information-schema.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 32. The Information Schema</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="information-schema.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="infoschema-constraint-column-usage.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INFOSCHEMA-COLUMNS"
>32.9. <VAR
CLASS="LITERAL"
>columns</VAR
></A
></H1
><P
>   The view <VAR
CLASS="LITERAL"
>columns</VAR
> contains information about all
   table columns (or view columns) in the database.  System columns
   (<VAR
CLASS="LITERAL"
>oid</VAR
>, etc.) are not included.  Only those columns are
   shown that the current user has access to (by way of being the
   owner or having some privilege).
  </P
><DIV
CLASS="TABLE"
><A
NAME="AEN25607"
></A
><P
><B
>Table 32-7. <VAR
CLASS="LITERAL"
>columns</VAR
> Columns</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Name</TH
><TH
>Data Type</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><VAR
CLASS="LITERAL"
>table_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Name of the database containing the table (always the current database)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>table_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Name of the schema containing the table</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>table_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Name of the table</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>column_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Name of the column</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>ordinal_position</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>Ordinal position of the column within the table (count starts at 1)</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>column_default</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>       Default expression of the column (null if the current user is
       not the owner of the table containing the column)
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>is_nullable</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>       <VAR
CLASS="LITERAL"
>YES</VAR
> if the column is possibly nullable,
       <VAR
CLASS="LITERAL"
>NO</VAR
> if it is known not nullable.  A not-null
       constraint is one way a column can be known not nullable, but
       there may be others.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>data_type</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>       Data type of the column, if it is a built-in type, or
       <VAR
CLASS="LITERAL"
>ARRAY</VAR
> if it is some array (in that case, see
       the view <VAR
CLASS="LITERAL"
>element_types</VAR
>), else
       <VAR
CLASS="LITERAL"
>USER-DEFINED</VAR
> (in that case, the type is
       identified in <VAR
CLASS="LITERAL"
>udt_name</VAR
> and associated
       columns).  If the column is based on a domain, this column
       refers to the type underlying the domain (and the domain is
       identified in <VAR
CLASS="LITERAL"
>domain_name</VAR
> and associated
       columns).
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>character_maximum_length</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies a character or bit
       string type, the declared maximum length; null for all other
       data types or if no maximum length was declared.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>character_octet_length</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies a character type,
       the maximum possible length in octets (bytes) of a datum (this
       should not be of concern to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> users); null for all
       other data types.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>numeric_precision</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies a numeric type, this
       column contains the (declared or implicit) precision of the
       type for this column.  The precision indicates the number of
       significant digits.  It may be expressed in decimal (base 10)
       or binary (base 2) terms, as specified in the column
       <VAR
CLASS="LITERAL"
>numeric_precision_radix</VAR
>.  For all other data
       types, this column is null.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>numeric_precision_radix</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies a numeric type, this
       column indicates in which base the values in the columns
       <VAR
CLASS="LITERAL"
>numeric_precision</VAR
> and
       <VAR
CLASS="LITERAL"
>numeric_scale</VAR
> are expressed.  The value is
       either 2 or 10.  For all other data types, this column is null.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>numeric_scale</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies an exact numeric
       type, this column contains the (declared or implicit) scale of
       the type for this column.  The scale indicates the number of
       significant digits to the right of the decimal point.  It may
       be expressed in decimal (base 10) or binary (base 2) terms, as
       specified in the column
       <VAR
CLASS="LITERAL"
>numeric_precision_radix</VAR
>.  For all other data
       types, this column is null.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>datetime_precision</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>       If <VAR
CLASS="LITERAL"
>data_type</VAR
> identifies a date, time, or
       interval type, the declared precision; null for all other data
       types or if no precision was declared.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>interval_type</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>Not yet implemented</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>interval_precision</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>Not yet implemented</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>character_set_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>character_set_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>character_set_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>collation_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>collation_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>collation_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>domain_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       If the column has a domain type, the name of the database that
       the domain is defined in (always the current database), else
       null.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>domain_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       If the column has a domain type, the name of the schema that
       the domain is defined in, else null.
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>domain_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>If the column has a domain type, the name of the domain, else null.</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>udt_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       Name of the database that the column data type (the underlying
       type of the domain, if applicable) is defined in (always the
       current database)
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>udt_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       Name of the schema that the column data type (the underlying
       type of the domain, if applicable) is defined in
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>udt_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       Name of the column data type (the underlying type of the
       domain, if applicable)
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>scope_catalog</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>scope_schema</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>scope_name</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>maximum_cardinality</VAR
></TD
><TD
><TT
CLASS="TYPE"
>cardinal_number</TT
></TD
><TD
>Always null, because arrays always have unlimited maximum cardinality in PostgreSQL</TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>dtd_identifier</VAR
></TD
><TD
><TT
CLASS="TYPE"
>sql_identifier</TT
></TD
><TD
>       An identifier of the data type descriptor of the column, unique
       among the data type descriptors pertaining to the table.  This
       is mainly useful for joining with other instances of such
       identifiers.  (The specific format of the identifier is not
       defined and not guaranteed to remain the same in future
       versions.)
      </TD
></TR
><TR
><TD
><VAR
CLASS="LITERAL"
>is_self_referencing</VAR
></TD
><TD
><TT
CLASS="TYPE"
>character_data</TT
></TD
><TD
>Applies to a feature not available in PostgreSQL</TD
></TR
></TBODY
></TABLE
></DIV
><P
>   Since data types can be defined in a variety of ways in SQL, and
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> contains additional ways to
   define data types, their representation in the information schema
   can be somewhat difficult.  The column <VAR
CLASS="LITERAL"
>data_type</VAR
>
   is supposed to identify the underlying built-in type of the column.
   In <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, this means that the type
   is defined in the system catalog schema
   <VAR
CLASS="LITERAL"
>pg_catalog</VAR
>.  This column may be useful if the
   application can handle the well-known built-in types specially (for
   example, format the numeric types differently or use the data in
   the precision columns).  The columns <VAR
CLASS="LITERAL"
>udt_name</VAR
>,
   <VAR
CLASS="LITERAL"
>udt_schema</VAR
>, and <VAR
CLASS="LITERAL"
>udt_catalog</VAR
>
   always identify the underlying data type of the column, even if the
   column is based on a domain.  (Since
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> treats built-in types like
   user-defined types, built-in types appear here as well.  This is an
   extension of the SQL standard.)  These columns should be used if an
   application wants to process data differently according to the
   type, because in that case it wouldn't matter if the column is
   really based on a domain.  If the column is based on a domain, the
   identity of the domain is stored in the columns
   <VAR
CLASS="LITERAL"
>domain_name</VAR
>, <VAR
CLASS="LITERAL"
>domain_schema</VAR
>,
   and <VAR
CLASS="LITERAL"
>domain_catalog</VAR
>.  If you want to pair up
   columns with their associated data types and treat domains as
   separate types, you could write <VAR
CLASS="LITERAL"
>coalesce(domain_name,
   udt_name)</VAR
>, etc.
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="infoschema-column-udt-usage.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="infoschema-constraint-column-usage.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><VAR
CLASS="LITERAL"
>column_udt_usage</VAR
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="information-schema.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><VAR
CLASS="LITERAL"
>constraint_column_usage</VAR
></TD
></TR
></TABLE
></DIV
></BODY
></HTML
>