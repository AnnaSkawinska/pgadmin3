<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>41.7. pg_attribute</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.2 Documentation">
<link rel="up" href="catalogs.html" title="Chapter 41. System Catalogs">
<link rel="previous" href="catalog-pg-attrdef.html" title="41.6. pg_attrdef">
<link rel="next" href="catalog-pg-cast.html" title="41.8. pg_cast">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="catalog-pg-attribute"></a>41.7. <tt class="structname">pg_attribute</tt></h2></div></div>
<div></div>
</div>
<a name="id2728032"></a><p>   The catalog <tt class="structname">pg_attribute</tt> stores information about
   table columns.  There will be exactly one
   <tt class="structname">pg_attribute</tt> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes, and indeed all objects that have <tt class="structname">pg_class</tt>
   entries.)
  </p>
<p>   The term attribute is equivalent to column and is used for
   historical reasons.
  </p>
<div class="table">
<a name="id2728063"></a><p class="title"><b>Table 41.7. <tt class="structname">pg_attribute</tt> Columns</b></p>
<table summary="pg_attribute Columns" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Name</th>
<th>Type</th>
<th>References</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><tt class="structfield">attrelid</tt></td>
<td><tt class="type">oid</tt></td>
<td><tt class="literal"><a href="catalog-pg-class.html" title="41.9. pg_class"><tt class="structname">pg_class</tt></a>.oid</tt></td>
<td>The table this column belongs to</td>
</tr>
<tr>
<td><tt class="structfield">attname</tt></td>
<td><tt class="type">name</tt></td>
<td> </td>
<td>The column name</td>
</tr>
<tr>
<td><tt class="structfield">atttypid</tt></td>
<td><tt class="type">oid</tt></td>
<td><tt class="literal"><a href="catalog-pg-type.html" title="41.30. pg_type"><tt class="structname">pg_type</tt></a>.oid</tt></td>
<td>The data type of this column</td>
</tr>
<tr>
<td><tt class="structfield">attstattarget</tt></td>
<td><tt class="type">int4</tt></td>
<td> </td>
<td>
<tt class="structfield">attstattarget</tt> controls the level of detail
       of statistics accumulated for this column by
       <a href="sql-analyze.html">ANALYZE</a>.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is data type-dependent.
       For scalar data types, <tt class="structfield">attstattarget</tt>
       is both the target number of &#8220;<span class="quote">most common values</span>&#8221;
       to collect, and the target number of histogram bins to create.
      </td>
</tr>
<tr>
<td><tt class="structfield">attlen</tt></td>
<td><tt class="type">int2</tt></td>
<td> </td>
<td>       A copy of <tt class="literal">pg_type.typlen</tt> of this column's
       type
      </td>
</tr>
<tr>
<td><tt class="structfield">attnum</tt></td>
<td><tt class="type">int2</tt></td>
<td> </td>
<td>       The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <tt class="structfield">oid</tt>,
       have (arbitrary) negative numbers.
      </td>
</tr>
<tr>
<td><tt class="structfield">attndims</tt></td>
<td><tt class="type">int4</tt></td>
<td> </td>
<td>       Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means &#8220;<span class="quote">it's an array</span>&#8221;.)
      </td>
</tr>
<tr>
<td><tt class="structfield">attcacheoff</tt></td>
<td><tt class="type">int4</tt></td>
<td> </td>
<td>       Always -1 in storage, but when loaded into a row descriptor
       in memory this may be updated to cache the offset of the attribute
       within the row.
      </td>
</tr>
<tr>
<td><tt class="structfield">atttypmod</tt></td>
<td><tt class="type">int4</tt></td>
<td> </td>
<td>
<tt class="structfield">atttypmod</tt> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <tt class="type">varchar</tt> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need <tt class="structfield">atttypmod</tt>.
      </td>
</tr>
<tr>
<td><tt class="structfield">attbyval</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>       A copy of <tt class="literal">pg_type.typbyval</tt> of this column's type
      </td>
</tr>
<tr>
<td><tt class="structfield">attstorage</tt></td>
<td><tt class="type">char</tt></td>
<td> </td>
<td>       Normally a copy of <tt class="literal">pg_type.typstorage</tt> of this
       column's type.  For TOAST-able data types, this can be altered
       after column creation to control storage policy.
      </td>
</tr>
<tr>
<td><tt class="structfield">attalign</tt></td>
<td><tt class="type">char</tt></td>
<td> </td>
<td>       A copy of <tt class="literal">pg_type.typalign</tt> of this column's type
      </td>
</tr>
<tr>
<td><tt class="structfield">attnotnull</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>       This represents a not-null constraint.  It is possible to
       change this column to enable or disable the constraint.
      </td>
</tr>
<tr>
<td><tt class="structfield">atthasdef</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>       This column has a default value, in which case there will be a
       corresponding entry in the <tt class="structname">pg_attrdef</tt>
       catalog that actually defines the value.
      </td>
</tr>
<tr>
<td><tt class="structfield">attisdropped</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>       This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL.
      </td>
</tr>
<tr>
<td><tt class="structfield">attislocal</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>       This column is defined locally in the relation.  Note that a column may
       be locally defined and inherited simultaneously.
      </td>
</tr>
<tr>
<td><tt class="structfield">attinhcount</tt></td>
<td><tt class="type">int4</tt></td>
<td> </td>
<td>       The number of direct ancestors this column has.  A column with a 
       nonzero number of ancestors cannot be dropped nor renamed.
      </td>
</tr>
</tbody>
</table>
</div>
<p>   In a dropped column's <tt class="structname">pg_attribute</tt> entry,
   <tt class="structfield">atttypid</tt> is reset to zero, but 
   <tt class="structfield">attlen</tt> and the other fields copied from
   <tt class="structname">pg_type</tt> are still valid.  This arrangement is needed
   to cope with the situation where the dropped column's data type was
   later dropped, and so there is no <tt class="structname">pg_type</tt> row anymore.
   <tt class="structfield">attlen</tt> and the other fields can be used
   to interpret the contents of a row of the table.
  </p>
</div></body>
</html>
