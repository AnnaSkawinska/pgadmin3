<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>41.3. pg_am</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.0.2 Documentation">
<link rel="up" href="catalogs.html" title="Chapter 41. System Catalogs">
<link rel="previous" href="catalog-pg-aggregate.html" title="41.2. pg_aggregate">
<link rel="next" href="catalog-pg-amop.html" title="41.4. pg_amop">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="catalog-pg-am"></a>41.3. <tt class="structname">pg_am</tt></h2></div></div>
<div></div>
</div>
<a name="id2727119"></a><p>   The catalog <tt class="structname">pg_am</tt> stores information about index access
   methods.  There is one row for each index access method supported by
   the system.
  </p>
<div class="table">
<a name="id2727136"></a><p class="title"><b>Table 41.3. <tt class="structname">pg_am</tt> Columns</b></p>
<table summary="pg_am Columns" border="1">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Name</th>
<th>Type</th>
<th>References</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td><tt class="structfield">amname</tt></td>
<td><tt class="type">name</tt></td>
<td> </td>
<td>Name of the access method</td>
</tr>
<tr>
<td><tt class="structfield">amowner</tt></td>
<td><tt class="type">int4</tt></td>
<td><tt class="literal"><a href="catalog-pg-shadow.html" title="41.26. pg_shadow"><tt class="structname">pg_shadow</tt></a>.usesysid</tt></td>
<td>User ID of the owner (currently not used)</td>
</tr>
<tr>
<td><tt class="structfield">amstrategies</tt></td>
<td><tt class="type">int2</tt></td>
<td> </td>
<td>Number of operator strategies for this access method</td>
</tr>
<tr>
<td><tt class="structfield">amsupport</tt></td>
<td><tt class="type">int2</tt></td>
<td> </td>
<td>Number of support routines for this access method</td>
</tr>
<tr>
<td><tt class="structfield">amorderstrategy</tt></td>
<td><tt class="type">int2</tt></td>
<td> </td>
<td>Zero if the index offers no sort order, otherwise the strategy
      number of the strategy operator that describes the sort order</td>
</tr>
<tr>
<td><tt class="structfield">amcanunique</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>Does the access method support unique indexes?</td>
</tr>
<tr>
<td><tt class="structfield">amcanmulticol</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>Does the access method support multicolumn indexes?</td>
</tr>
<tr>
<td><tt class="structfield">amindexnulls</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>Does the access method support null index entries?</td>
</tr>
<tr>
<td><tt class="structfield">amconcurrent</tt></td>
<td><tt class="type">bool</tt></td>
<td> </td>
<td>Does the access method support concurrent updates?</td>
</tr>
<tr>
<td><tt class="structfield">amgettuple</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Next valid tuple</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">aminsert</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Insert this tuple</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">ambeginscan</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Start new scan</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">amrescan</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Restart this scan</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">amendscan</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">End this scan</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">ammarkpos</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Mark current scan position</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">amrestrpos</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Restore marked scan position</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">ambuild</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>&#8220;<span class="quote">Build new index</span>&#8221; function</td>
</tr>
<tr>
<td><tt class="structfield">ambulkdelete</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>Bulk-delete function</td>
</tr>
<tr>
<td><tt class="structfield">amvacuumcleanup</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>Post-<tt class="command">VACUUM</tt> cleanup function</td>
</tr>
<tr>
<td><tt class="structfield">amcostestimate</tt></td>
<td><tt class="type">regproc</tt></td>
<td><tt class="literal"><a href="catalog-pg-proc.html" title="41.24. pg_proc"><tt class="structname">pg_proc</tt></a>.oid</tt></td>
<td>Function to estimate cost of an index scan</td>
</tr>
</tbody>
</table>
</div>
<p>    An index access method that supports multiple columns (has
    <tt class="structfield">amcanmulticol</tt> true) <span class="emphasis"><em>must</em></span>
    support indexing null values in columns after the first, because the planner
    will assume the index can be used for queries on just the first
    column(s).  For example, consider an index on (a,b) and a query with
    <tt class="literal">WHERE a = 4</tt>.  The system will assume the index can be used to scan for
    rows with <tt class="literal">a = 4</tt>, which is wrong if the index omits rows where <tt class="literal">b</tt> is null.
    It is, however, OK to omit rows where the first indexed column is null.
    (GiST currently does so.)
    <tt class="structfield">amindexnulls</tt> should be set true only if the
    index access method indexes all rows, including arbitrary combinations of null values.
   </p>
</div></body>
</html>
