<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>35.5. Expressions</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.1devel Documentation">
<link rel="up" href="plpgsql.html" title="Chapter 35. PL/pgSQL - SQL Procedural Language">
<link rel="previous" href="plpgsql-declarations.html" title="35.4. Declarations">
<link rel="next" href="plpgsql-statements.html" title="35.6. Basic Statements">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="plpgsql-expressions"></a>35.5. Expressions</h2></div></div>
<div></div>
</div>
<p>     All expressions used in <span class="application">PL/pgSQL</span>
     statements are processed using the server's regular
     <span class="acronym">SQL</span> executor.  In effect, a query like
</p>
<pre class="synopsis">SELECT <i class="replaceable"><tt>expression</tt></i></pre>
<p>
     is executed using the <span class="acronym">SPI</span> manager. Before evaluation,
     occurrences of <span class="application">PL/pgSQL</span> variable
     identifiers are replaced by parameters, and the actual values from
     the variables are passed to the executor in the parameter array.
     This allows the query plan for the <tt class="command">SELECT</tt> to
     be prepared just once and then reused for subsequent
     evaluations.
    </p>
<p>     The evaluation done by the <span class="productname">PostgreSQL</span>
     main parser has some side
     effects on the interpretation of constant values. In detail there
     is a difference between what these two functions do:

</p>
<pre class="programlisting">CREATE FUNCTION logfunc1(logtxt text) RETURNS timestamp AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
        RETURN 'now';
    END;
$$ LANGUAGE plpgsql;</pre>
<p>

     and

</p>
<pre class="programlisting">CREATE FUNCTION logfunc2(logtxt text) RETURNS timestamp AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
        RETURN curtime;
    END;
$$ LANGUAGE plpgsql;</pre>
<p>
    </p>
<p>     In the case of <tt class="function">logfunc1</tt>, the 
     <span class="productname">PostgreSQL</span> main parser knows when 
     preparing the plan for the <tt class="command">INSERT</tt>, that the string 
     <tt class="literal">'now'</tt> should be interpreted as 
     <tt class="type">timestamp</tt> because the target column of <tt class="classname">logtable</tt>
     is of that type. Thus, it will make a constant from it at this
     time and this constant value is then used in all invocations of 
     <tt class="function">logfunc1</tt> during the lifetime of the
     session. Needless to say that this isn't what the
     programmer wanted.
    </p>
<p>     In the case of <tt class="function">logfunc2</tt>, the 
     <span class="productname">PostgreSQL</span> main parser does not know
     what type <tt class="literal">'now'</tt> should become and therefore 
     it returns a data value of type <tt class="type">text</tt> containing the string 
     <tt class="literal">now</tt>. During the ensuing assignment
     to the local variable <tt class="varname">curtime</tt>, the
     <span class="application">PL/pgSQL</span> interpreter casts this
     string to the <tt class="type">timestamp</tt> type by calling the
     <tt class="function">text_out</tt> and <tt class="function">timestamp_in</tt>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.
    </p>
<p>     The mutable nature of record variables presents a problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change between calls of one and the same expression, since the
     expression will be planned using the data type that is present
     when the expression is first reached.  Keep this in mind when
     writing trigger procedures that handle events for more than one
     table.  (<tt class="command">EXECUTE</tt> can be used to get around
     this problem when necessary.)
    </p>
</div></body>
</html>
