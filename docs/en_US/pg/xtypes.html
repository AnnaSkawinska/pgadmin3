<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>User-Defined Types</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="User-Defined Aggregates"
HREF="xaggr.html"><LINK
REL="NEXT"
TITLE="User-defined Operators"
HREF="xoper.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-10-03T03:19:47"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="xaggr.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 33. Extending <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="extend.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="xoper.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XTYPES"
>33.11. User-Defined Types</A
></H1
><A
NAME="AEN29894"
></A
><P
>   As described above, there are two kinds of data types in
   <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>: base types and composite
   types. This section describes how to define new base types.
  </P
><P
>   The examples in this section can be found in
   <TT
CLASS="FILENAME"
>complex.sql</TT
> and <TT
CLASS="FILENAME"
>complex.c</TT
>
   in the tutorial directory.
  </P
><P
>  <A
NAME="AEN29904"
></A
>
  <A
NAME="AEN29906"
></A
>
  A user-defined type must always have input and output
  functions.<A
NAME="AEN29908"
></A
><A
NAME="AEN29911"
></A
>
  These functions determine how the type appears in strings (for input
  by the user and output to the user) and how the type is organized in
  memory.  The input function takes a null-terminated character string
  as its argument and returns the internal (in memory) representation
  of the type.  The output function takes the internal representation
  of the type as argument and returns a null-terminated character
  string.
 </P
><P
>  Suppose we want to define a type <TT
CLASS="TYPE"
>complex</TT
> that represents
  complex numbers. A natural way to to represent a complex number in
  memory would be the following C structure:

</P><PRE
CLASS="PROGRAMLISTING"
>typedef struct Complex {
    double      x;
    double      y;
} Complex;</PRE
><P>

  As the external string representation of the type, we choose a
  string of the form <VAR
CLASS="LITERAL"
>(x,y)</VAR
>.
 </P
><P
>  The input and output functions are usually not hard to write,
  especially the output function.  But when defining the external
  string representation of the type, remember that you must eventually
  write a complete and robust parser for that representation as your
  input function.  For instance:

</P><PRE
CLASS="PROGRAMLISTING"
>Complex *
complex_in(char *str)
{
    double      x,
                y;
    Complex    *result;

    if (sscanf(str, " ( %lf , %lf )", &amp;x, &amp;y) != 2)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                 errmsg("invalid input syntax for complex: \"%s\"", str)));

    result = (Complex *) palloc(sizeof(Complex));
    result-&gt;x = x;
    result-&gt;y = y;
    return result;
}</PRE
><P>

  The output function can simply be:

</P><PRE
CLASS="PROGRAMLISTING"
>char *
complex_out(Complex *complex)
{
    char *result;

    if (complex == NULL)
        return(NULL);
    result = (char *) palloc(60);
    sprintf(result, "(%g,%g)", complex-&gt;x, complex-&gt;y);
    return result;
}</PRE
><P>
 </P
><P
>  You should try to make the input and output functions inverses of
  each other.  If you do not, you will have severe problems when you
  need to dump your data into a file and then read it back in.  This
  is a particularly common problem when floating-point numbers are
  involved.
 </P
><P
>  To define the <TT
CLASS="TYPE"
>complex</TT
> type, we need to create the two
  user-defined functions <CODE
CLASS="FUNCTION"
>complex_in</CODE
> and
  <CODE
CLASS="FUNCTION"
>complex_out</CODE
> before creating the type:

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION complex_in(cstring)
    RETURNS complex
    AS '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>'
    LANGUAGE C;

CREATE FUNCTION complex_out(complex)
    RETURNS cstring
    AS '<VAR
CLASS="REPLACEABLE"
>filename</VAR
>'
    LANGUAGE C;</PRE
><P>

  Notice that the declarations of the input and output functions must
  reference the not-yet-defined type.  This is allowed, but will draw
  warning messages that may be ignored.
 </P
><P
>  Finally, we can declare the data type:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE complex (
    internallength = 16,
    input = complex_in,
    output = complex_out
);</PRE
><P>
 </P
><P
>  When you define a new base type,
  <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> automatically provides support
  for arrays of that
  type.<A
NAME="AEN29933"
></A
> For historical reasons, the array type
  has the same name as the base type with the underscore character
  (<VAR
CLASS="LITERAL"
>_</VAR
>) prepended.
 </P
><P
>  If the values of your data type might exceed a few hundred bytes in
  size (in internal form), you should mark them
  TOAST-able.<A
NAME="AEN29938"
></A
> To do this, the internal
  representation must follow the standard layout for variable-length
  data: the first four bytes must be an <TT
CLASS="TYPE"
>int32</TT
> containing
  the total length in bytes of the datum (including itself).  Also,
  when running the <TT
CLASS="COMMAND"
>CREATE TYPE</TT
> command, specify the
  internal length as <VAR
CLASS="LITERAL"
>variable</VAR
> and select the appropriate
  storage option.
 </P
><P
>  For further details see the description of the
  <A
HREF="sql-createtype.html"
><I
>CREATE TYPE</I
></A
> command.
 </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xaggr.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xoper.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>User-Defined Aggregates</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>User-defined Operators</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>