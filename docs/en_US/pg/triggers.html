<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Triggers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta4 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Server Programming"
HREF="server-programming.html"><LINK
REL="PREVIOUS"
TITLE="Rules versus Triggers"
HREF="rules-triggers.html"><LINK
REL="NEXT"
TITLE="Interaction with the Trigger Manager"
HREF="trigger-manager.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-10-03T03:19:47"></HEAD
><BODY
CLASS="CHAPTER"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
>PostgreSQL 7.4beta4 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="rules-triggers.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="rules.html"
>Fast Backward</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="spi.html"
>Fast Forward</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
HREF="trigger-manager.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="TRIGGERS"
></A
>Chapter 36. Triggers</H1
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>36.1. <A
HREF="triggers.html#TRIGGER-DEFINITION"
>Trigger Definition</A
></DT
><DT
>36.2. <A
HREF="trigger-manager.html"
>Interaction with the Trigger Manager</A
></DT
><DT
>36.3. <A
HREF="trigger-datachanges.html"
>Visibility of Data Changes</A
></DT
><DT
>36.4. <A
HREF="trigger-example.html"
>A Complete Example</A
></DT
></DL
></DIV
><A
NAME="AEN31196"
></A
><P
>   This chapter describes how to write trigger functions.  In
   particular, it describes the C-language interface for trigger
   functions.  The trigger interfaces in most procedural languages
   work analogously.  (Trigger functions cannot be written in SQL.)
  </P
><P
>   A trigger function can execute before or after a
   <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
>, or
   <TT
CLASS="COMMAND"
>DELETE</TT
>, either once per modified row, or once
   per <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
> statement.
  </P
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TRIGGER-DEFINITION"
>36.1. Trigger Definition</A
></H1
><P
>    If a trigger event occurs, the trigger manager is called by the
    executor.  It sets up an information structure of type
    <TT
CLASS="STRUCTNAME"
>TriggerData</TT
> (described below) and calls the trigger
    function to handle the event.
   </P
><P
>    The trigger function must be defined before the trigger itself can be
    created.  The trigger function must be declared as a 
    function taking no arguments and returning type <VAR
CLASS="LITERAL"
>trigger</VAR
>.
    (The trigger function receives its input through a <TT
CLASS="STRUCTNAME"
>TriggerData</TT
>
    structure, not in the form of ordinary function arguments.)
    If the function is written in C, it must use the <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
>
    function manager interface.
   </P
><P
>    The syntax for creating triggers is described in
    <A
HREF="sql-createtrigger.html"
><I
>CREATE TRIGGER</I
></A
>.
   </P
><P
>    Trigger functions return a value of type <TT
CLASS="STRUCTNAME"
>HeapTuple</TT
>,
    which represents a table row, to the calling executor.  The return
    value is ignored for triggers fired after an operation, but a
    triggers fired before an operation has the following choices:

    <P
></P
></P><UL
><LI
><P
>       It can return a <TT
CLASS="SYMBOL"
>NULL</TT
> pointer to skip the operation
       for the current row (and so the row will not be
       inserted/updated/deleted).
      </P
></LI
><LI
><P
>       For <TT
CLASS="COMMAND"
>INSERT</TT
> and <TT
CLASS="COMMAND"
>UPDATE</TT
>
       triggers only, the returned row becomes the row that will
       be inserted or will replace the row being updated.  This
       allows the trigger function to modify the row being inserted or
       updated.
      </P
></LI
></UL
><P>

    A before trigger that does not intend to cause either of these
    behaviors must be careful to return the same row that was passed
    in as the new row (see below).
   </P
><P
>    If more than one trigger is defined for the same event on the same
    relation, the triggers will be fired in alphabetical order by
    name.  In the case of before triggers, the possibly-modified row
    returned by each trigger becomes the input to the next trigger.
    If any before trigger returns a <TT
CLASS="SYMBOL"
>NULL</TT
> pointer, the
    operation is abandoned and subsequent triggers are not fired.
   </P
><P
>    If a trigger function executes SQL commands (using SPI) then these
    commands may fire triggers again. This is known as cascading
    triggers.  There is no direct limitation on the number of cascade
    levels.  It is possible for cascades to cause a recursive invocation
    of the same trigger; for example, an <TT
CLASS="COMMAND"
>INSERT</TT
>
    trigger might execute a command that inserts an additional row
    into the same table, causing the <TT
CLASS="COMMAND"
>INSERT</TT
> trigger
    to be fired again.  It is the trigger programmer's responsibility
    to avoid infinite recursion in such scenarios.
   </P
><P
>    When a trigger is being defined, arguments can be specified for
    it.<A
NAME="AEN31230"
></A
> The purpose of including arguments in the
    trigger definition is to allow different triggers with similar
    requirements to call the same function.  As an example, there
    could be a generalized trigger function that takes as its
    arguments two column names and puts the current user in one and
    the current time stamp in the other.  Properly written, this
    trigger function would be independent of the specific table it is
    triggering on.  So the same function could be used for
    <TT
CLASS="COMMAND"
>INSERT</TT
> events on any table with suitable
    columns, to automatically track creation of records in a
    transaction table for example. It could also be used to track
    last-update events if defined as an <TT
CLASS="COMMAND"
>UPDATE</TT
>
    trigger.
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="rules-triggers.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="trigger-manager.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Rules versus Triggers</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="server-programming.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Interaction with the Trigger Manager</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>