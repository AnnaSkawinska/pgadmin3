<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<link rel="STYLESHEET" type="text/css" href="pgadmin3.css">
<title>Référence du langage de script pgScript</title>
</head>

<body>

<h3>Référence du langage de script pgScript</h3>

<p><b>Sommaire</b></p>
<ul>
    <li><a href="#overview">Aperçu</a></li>
    <li><a href="#examples">Exemples</a></li>
    <ul>
        <li><a href="#example1">Créer des tables par batch</a></li>
        <li><a href="#example2">Insérer des données aléatoires</a></li>
        <li><a href="#example3">Supprimer des tables par batch</a></li>
        <li><a href="#example4">Afficher des informations à l'écran</a></li>
    </ul>
    <li><a href="#commands">Commandes SQL</a></li>
    <li><a href="#variables">Variables</a></li>
    <ul>
        <li><a href="#variable1">Variables simples</a></li>
        <li><a href="#variable2">Enregistrements</a></li>
        <li><a href="#variable3">Conversion</a></li>
        <li><a href="#variable4">Opérations</a></li>
    </ul>
    <li><a href="#control">Structures de contrôle</a></li>
    <ul>
        <li><a href="#control1">Structures conditionnelles</a></li>
        <li><a href="#control2">Structures de boucle</a></li>
        <li><a href="#control3">Conditions</a></li>
    </ul>
    <li><a href="#functions">Fonctions et procédures supplémentaires</a></li>
    <ul>
        <li><a href="#function1">Procédures</a></li>
        <li><a href="#function2">Fonctions</a></li>
    </ul>
    <li><a href="#generators">Générateurs de données aléatoires</a></li>
    <ul>
        <li><a href="#generator1">Aperçu des générateurs</a></li>
        <li><a href="#generator2">Séquence et grain</a></li>
        <li><a href="#generator3">Générateurs de données</a></li>
    </ul>
</ul>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="overview"></a>Aperçu</h3>
<p>pgScript est composé de commandes pgScript&nbsp;:</p>
<pre class="screen">commande pgScript
    : commande standard SQL PostgreSQL (SELECT INSERT CREATE ...)
    | déclaration ou affectation de variable (DECLARE SET)
    | structure de contrôle (IF WHILE)
    | procédure (ASSERT PRINT LOG RMLINE)</pre>
<p>Les noms de commandes (<strong class="command">SELECT</strong>, <strong
class="command">IF</strong>, <strong class="command">SET</strong>, ...) ne
sont pas sensibles à la casse et doivent se terminer avec un point-virgule
(<code>;</code>). Les identifiants sont sensibles à la casse.</p>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="examples"></a>Exemples</h3>
<h4><a name="example1"></a>Créer des tables par batch</h4>
<pre class="screen">DECLARE @I, @T; -- Les noms de variables commencent avec un @
SET @I = 0; -- @I est un entier
WHILE @I &lt; 20
BEGIN
    SET @T = 'table' + CAST (@I AS STRING); -- Convertie @I
    CREATE TABLE @T (id integer primary key, data text);

    SET @I = @I + 1;
END</pre>
<h4><a name="example2"></a>Insérer des données aléatoires</h4>
<pre class="screen">DECLARE @I, @J, @T, @G;
SET @I = 0;
SET @G1 = INTEGER(10, 29, 1); /* Générateur aléatoire d'entiers
                             nombres uniques entre 10 et 29 */
SET @G2 = STRING(10, 20, 3); /* Générateur aléatoire de chaînes de caractères
                             3 mots entre 10 et 20 caractères */
WHILE @I &lt; 20
BEGIN
    SET @T = 'table' + CAST (@I AS STRING);

    SET @J = 0;
    WHILE @J &lt; 20
    BEGIN
        INSERT INTO @T VALUES (@G1, '@G2');
        SET @J = @J + 1;
    END

    SET @I = @I + 1;
END</pre>
<h4><a name="example3"></a>Supprimer des tables par batch</h4>
<pre class="screen">DECLARE @I, @T; -- Déclaration optionnelle
SET @I = 0;
WHILE 1 -- Toujours true
BEGIN
    IF @I &gt;= 20
      BREAK; -- Quitte la boucle si @I &gt; 20

    SET @T = 'table' + CAST (@I AS STRING);
    DROP TABLE @T;

    SET @I = @I + 1;
END</pre>
<h4><a name="example4"></a>Affiches des informations à l'écran</h4>
<pre class="screen">SET @PROGR@M#TITLE = 'pgScript';
PRINT '';
PRINT @PROGR@M#TITLE + ' features:';
PRINT '';
PRINT '  * Regular PostgreSQL commands';
PRINT '  * Control-of-flow language';
PRINT '  * Local variables';
PRINT '  * Random data generators';</pre>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="commands"></a>Commandes SQL</h3>
<p>Vous pouvez exécuter toute requête PostgreSQL dans un script pgScript sauf
celles-ci&nbsp;:</p>
<pre class="screen">BEGIN;
END;</pre>
<p>La cause en est que <strong class="command">BEGIN</strong> et <strong
class="command">END</strong> sont déjà utilisés pour délimiter les blocs. À
la place, utilisez&nbsp;:</p>
<pre class="screen">BEGIN TRANSACTION;
END TRANSACTION;</pre>
<p>Pour une liste des commandes PostgreSQL, voir: <a
href="http://docs.postgresql.fr/8.3/sql-commands.html"
target="_blank">http://docs.postgresql.fr/8.3/sql-commands.html</a>.</p>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="variables"></a>Variables</h3>
<p>Il existe deux types de variables&nbsp;: les variables simples et les
enregistrements (ensembles de résultats composés de lignes et de colonnes).</p>
<p>Les noms des variables commencent avec un <code>@</code> et peuvent être
composés de lettres, de chiffres et des caractères <code>_</code>,
<code>#</code>, <code>@</code>.</p>
<p>Le type de variable est deviné automatiquement suivant le type de la valeur
qu'il contient. Voici le choix possible&nbsp;: nombre (real ou integer), chaîne
(string), enregistrement (record).</p>
<h4><a name="variable1"></a>Variables simples</h4>
<h5>Déclaration de variable simple</h5>
<p>Déclarer une variable simple est optionnel.</p>
<pre class="screen">DECLARE @A, @B;
DECLARE @VAR1;</pre>
<h5>Affectation de variable simple</h5>
<p>Cela se fait avec la commande <strong class="command">SET</strong>. Le type
de variable dépend de la valeur affectée à cette variable.</p>
<pre class="screen">SET @A = 1000, @B = 2000;   -- @A et @B sont des <strong>nombres entiers</strong>
SET @C = 10e1, @D = 1.5;    -- @C et @D sont des <strong>nombres flottants</strong>
SET @E = 'ab', @F = 'a''b'; -- @E et @F sont des <strong>chaînes de caractères</strong>
SET @G = "ab", @H = "a\"b"; -- @G et @H sont des <strong>chaînes de caractères</strong></pre>
<p>Une variable non initialisée est par défaut une chaîne vide. Il est possible
de surcharger les variables autant de fois que nécessaire.</p>
<pre class="screen">PRINT @A;      -- Affiche une chaîne vide
SET @A = 1000; -- @A est initialisé en tant qu'entier
PRINT @A;      -- Affiche 1000
SET @A = 'ab'; -- @A devient une chaîne
PRINT @A;      -- Affiche ab</pre>
<h5>Générateurs de données</h5>
<p>Les générateurs de données permettent aux utilisateurs de générer des valeurs
aléatoires. Il existe différents types de générateurs, chacune produisant un
type différent de données. Une variable initialisée avec un générateur de
données se comporte comme une variable simple normale sauf qu'elle a une valeur
différente à chaque fois qu'elle est utilisée.</p>
<pre class="screen">SET @A = INTEGER(100, 200);
PRINT @A; -- Affiche un entier entre 100 et 200
PRINT @A; -- Affiche un autre entier entre 100 et 200</pre>
<p>Une variable peut contenir un générateur, mais son type sera soit un nombre
(real ou integer) soit une chaîne. Pour une liste des générateurs disponibles
et leur type associé, voir <a href="#generators">Générateur de données
aléatoires</a>.</p>
<h4><a name="variable2"></a>Enregistrements</h4>
<h5>Déclaration d'un enregistrement</h5>
<p>Déclarer un enregistrement est <strong>requis</strong>. Un nom pour chaque
colonne doit être spécifié même si elles ne seront pas utilisées après.</p>
<pre class="screen">DECLARE @R1 { @A, @B }, @R2 { @A, @C }; -- Deux enregistrements avec deux colonnes
DECLARE @R3 { @A, @B, @C, @D };         -- Un enregistrement avec quatre colonnes</pre>
<p>Le nombre de lignes est dynamiques&nbsp;: voir la prochaine section.</p>
<h5>Affectation de l'enregistrement</h5>
<p>Pour accéder à un emplacement spécifique d'un enregistrement, vous pouvez
utiliser le numéro de ligne (commence à 0) et peut utiliser soit le nom de la
colonne (entre guillemets) ou le numéro de la colonne (commence à 0). Cette
emplacement spécifique se comporte comme une variable simple. Notez qu'un
enregistrement ne peut pas contenir un enregistrement.</p>
<pre class="screen">SET @R1[0]['@A'] = 1; -- Première ligne &amp; première colonne
SET @R1[0][0] = 1;    -- Même emplacement
SET @R1[4]['@B'] = 1; -- Cinquième ligne &amp; deuxième colonne
SET @R1[0][1] = 1;    -- Même emplacement</pre>
<p>Dans l'exemple ci-dessus, les trois lignes lignes sont automatiquement
insérées entre la première et la cinquième. Utiliser un nombre ou un nom de
colonne invalide cause une exception.</p>
<p>Un emplacement spécifique peut être utilisé comme une valeur valide. Une ligne
spécifique peut aussi être utilisée comme valeur.</p>
<pre class="screen">SET @R1[0][0] = @R3[0][1], @A = @R2[0][0]; -- Se comporte commes des variables simples
SET @A = @R1[1]; -- @A devient un enregistrement qui est la première ligne de @R1</pre>
<p>Souvenez-vous que <code>SET @R1[0][0] = @R2</code> est impossible car un
enregistrement ne peut pas contenir un enregistrement.</p>
<p>Il est possible d'affecter un enregistrement dans une variable. Dans ce cas,
la variable n'a pas besoin d'être déclarée&nbsp;:</p>
<pre class="screen">SET @A = @R3; -- @A devient un enregistrement car il se voit affecter un enregistrement</pre>
<h5>Requêtes SQL</h5>
<p>Toute requête SQL exécutée renvoie un enregistrement. Si la requête est un
<code>SELECT</code>, alors elle renvoie les résultats de la requête. Si c'est
quelque-chose d'autre, alors elle renvoie un enregistrement d'une ligne
(<code>true</code>) si c'est un succès, et un enregistrement sans ligne
dans le cas contraire (<code>false</code>).</p>
<pre class="screen">SET @A = SELECT * FROM table;   -- @A est un enregistrement avec les résultats de la requête
SET @B = INSERT INTO table ...; -- @B est un enregistrement d'une ligne si la requête réussit</pre>
<h5>Fonctions des enregistrements</h5>
<p>Voir <a href="#function2">Fonctions</a>.</p>
<h4><a name="variable3"></a>Conversion</h4>
<p>Il est possible de convertir une variable d'un type vers un autre avec la
fonction de conversion&nbsp;:</p>
<pre class="screen">SET @A = CAST (@B AS STRING);
SET @A = CAST (@B AS REAL);
SET @A = CAST (@B AS INTEGER);
SET @A = CAST (@B AS RECORD);</pre>
<p>Quand un enregistrement est converti en une chaîne de caractères, il est
converti dans sa représentation plate. Quand il est converti en un nombre,
l'enregistrement est tout d'abord converti en une chaîne, puis en un nombre
(voir la conversion des chaînes pour plus de détails).</p>
<p>Quand un nombre est converti en chaîne, il est converti en utilisant sa
représentation de chaîne. Quand il est converti en un enregistrement, il est
converti en un enregistrement d'une ligne et une colonne dont la valeur est
le nombre.</p>
<p>Quand une chaîne est convertie en un nombre, si la chaîne représente un
nombre, alors ce dernier est renvoyé, sinon une exception est levée. Quand
elle est convertie en un enregistrement, soit le programme peut trouver
un <strong>modèle d'enregistrement</strong> dans la chaîne soit il est
converti en un enregistrement d'une ligne et une colonne dont la valeur est
la chaîne. Un modèle d'enregistrement est&nbsp;:</p>
<pre class="screen">SET @B = '(1, "abc", "ab\\"")(1, "abc", "ab\\"")'; -- @B est une chaîne
SET @B = CAST (@B AS RECORD); @B devient un enregistrement de deux lignes et de trois colonnes</pre>
<p>Rappelez-vous qu'une chaîne est entourée par des guillemets simples. Les
chaînes composant un enregistrement doit être entouré par des guillemets doubles
qui sont échappés avec <code>\\</code> (nous doublons l'antislash car il est déjà
un caractère spécial pour les guillemets simples).</p>
<h4><a name="variable4"></a>Opérations</h4>
<p>Les opérations peuvent seulement être réalisées entre des opérandes de même
type. Convertissez les valeurs pour vous conformer à cette règle.</p>
<p>Le résultat des comparaisons est un nombre 0 ou 1.</p>
<h5>Chaînes</h5>
<p>Comparaisons&nbsp;: <code>= &lt;&gt; &gt; &lt; &lt;= &gt;= AND
    OR</code></p>
<p>Concaténation&nbsp;: <code>+</code></p>
<pre class="screen">SET @B = @A + 'abcdef'; -- @A et @B doivent être une chaîne</pre>
<p>Valeur booléenne&nbsp;: une chaîne non vide est <code>true</code>, une
chaîne vide est <code>false</code></p>
<p>Inverser une valeur booléenne&nbsp;: <code>NOT</code></p>
<p>Comparaison sans prendre en compte la casse&nbsp;: <code>~=</code></p>
<h5>Nombres</h5>
<p>Comparaisons&nbsp;: <code>= &lt;&gt; &gt; &lt; &lt;= &gt;= AND
    OR</code></p>
<p>Arithmétique&nbsp;: <code>+ - * / %</code></p>
<pre class="screen">SET @A = CAST ('10' AS INTEGER) + 5; -- La chaîne '10' est convertie en un nombre</pre>
<p>Valeur booléenne&nbsp;: 0 est <code>false</code>, tout le reste est <code>true</code></p>
<p>Inverser une valeur booléenne: <code>NOT</code> (notez que <code>NOT NOT 10 = 1</code>)</p>
<p>Une opération arithmétique impliquant au moins un nombre flottant donne un
nombre flottant en résultat&nbsp;:</p>
<pre class="screen">SET @A = 10 / 4.; -- 4. est un nombre flottant, donc un résultat en nombre flottant: @A = 2.5
SET @A = 10 / 4;  -- 4 est un entier, donc un résultat en entier: @A = 2</pre>
<h5>Enregistrements</h5>
<p>Comparaisons&nbsp;: <code>= &lt;&gt; &gt; &lt; &lt;= &gt;= AND
    OR</code></p>
<p>Valeur booléenne: un enregistrement de zéro ligne vaut <code>false</code>,
tout le reste vaut <code>true</code></p>
<p>Inverser une valeur booléenne&nbsp;: <code>NOT</code></p>
<p>Comparaisons pour les enregistrements sur l'inclusion et l'exclusion. L'ordre
des lignes n'importe pas. <code>&lt;=</code> signifie que chaque ligne dans
l'opérande gauche a une correspondance dans l'opérande de droite.
<code>&gt;=</code> signifie l'inverse. <code>=</code> signifie que
<code>&lt;=</code> et <code>&gt;=</code> sont tous les deux true...</p>
<p>Les comparaisons sont réalisées sur les chaînes&nbsp;: même si un enregistrement
contient des nombres comme <code>10</code> et <code>1e1</code>, nous aurons
<code>'10' &lt;&gt; '1e1'</code>.</p>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="control"></a>Structures de contrôle</h3>
<h4><a name="control1"></a>Structure conditionnelle</h4>
<pre class="screen">IF condition
BEGIN
    commandes pgScript
END
ELSE
BEGIN
    commandes pgScript
END</pre>
<p>Les commandes pgScript sont optionnelles. Les mots clés <strong
class="command">BEGIN</strong> et <strong class="command">END</strong> sont
optionnels s'il y a une seule commande pgScript.</p>
<h4><a name="control2"></a>Structure de boucle</h4>
<pre class="screen">WHILE condition
BEGIN
    commandes pgScript
END</pre>
<p>Les commandes pgScript sont optionnelles. Les mots clés <strong
class="command">BEGIN</strong> et <strong class="command">END</strong> sont
optionnels s'il y a une seule commande pgScript.</p>
<p><strong class="command">BREAK</strong> termine la boucle <strong
class="command">WHILE</strong> alors que <strong class="command">CONTINUE</strong>
provoque la prochaine itération de la boucle en cours d'exécution. <strong
class="command">RETURN</strong> se comporte comme <strong
class="command">BREAK</strong>.</p>
<pre class="screen">WHILE condition1
BEGIN
    IF condition2
    BEGIN
        BREAK;
    END
END</pre>
<h4><a name="control3"></a>Conditions</h4>
<p>Les conditions sont en fait les résultats d'opérations. Par exemple, la
comparaison de chaînes <code>'ab' = 'ac'</code> résulte en un nombre qui est
<code>false</code> (l'égalité n'est pas vraie).</p>
<pre class="screen">IF 'ab' ~= 'AB' -- Comparaison sans attention à la casse qui donne pour résultat 1 (true)
BEGIN
    -- On entre ici
END

IF 0 -- faux
BEGIN
    -- On n'arrive <strong>pas</strong> ici
END
ELSE
BEGIN
    -- On entre ici
END

WHILE 1
BEGIN
    -- Boucle infinie : utiliser BREAK pour sortir
END</pre>
<p>Il est possible d'utiliser le résultat d'une requête SQL SELECT comme
condition. La requête a besoin d'être entourée avec des parenthèses&nbsp;:</p>
<pre class="screen">IF (SELECT 1 FROM table)
BEGIN
    -- Ceci signifie que la table existe, sinon la condition serait fausse
END</pre>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="functions"></a>Fonctions et procédures supplémentaires</h3>
<h4><a name="function1"></a>Procédures</h4>
<p>Les procédures ne renvoient pas de résultat. Elles doivent être utilisées
seules sur une ligne et ne peuvent pas être affectées à une variable.</p>
<h5>Print</h5>
<p>Affiche une expression sur l'écran&nbsp;:</p>
<pre class="screen">PRINT 'La valeur de @A est ' + CAST (@A AS STRING);</pre>
<h5>Assert</h5>
<p>Renvoie une exception si l'expression évaluée est false&nbsp;:</p>
<pre class="screen">ASSERT 5 &gt; 3 AND 'a' = 'a';</pre>
<h5>Remove line</h5>
<p>Supprime la ligne spécifiée d'un enregistrement&nbsp;:</p>
<pre class="screen">RMLINE(@R[1]); -- Supprime la deuxième ligne de @R</pre>
<h4><a name="function2"></a>Fonctions</h4>
<p>Les fonctions renvoient un résultat. Leur code de retour peut être affecté
à une variable, comme l'opération <code>CAST</code>.</p>
<h5>Trim</h5>
<p>Supprime les espaces devant et derrière une chaîne de caractères&nbsp;:</p>
<pre class="screen">SET @A = TRIM(' a '); -- @A = 'a'</pre>
<h5>Lines</h5>
<p>Renvoie le nombre de lignes d'un enregistrement&nbsp;:</p>
<pre class="screen">IF LINES(@R) &gt; 0
BEGIN
    -- Traitement
END</pre>
<h5>Columns</h5>
<p>Renvoie le nombre de colonnes d'un enregistrement&nbsp;:</p>
<pre class="screen">IF COLUMNS(@R) &gt; 0
BEGIN
    -- Traitement
END</pre>

<!-- ----------------------------------------------------------------------  -->

<h3><a name="generators"></a>Générateurs aléatoires de données</h3>
<h4><a name="generator1"></a>Aperçu des générateurs</h4>
<p>Un utilisateur peut affecter une variable (<strong class="command">SET</strong>)
avec un génération de données. Cela signifie que chaque fois que la variable
sera utilisée, elle aura une valeur différente.</p>
<p>Néanmoins, la variable est toujours utilisée comme d'habitude&nbsp;:</p>
<pre class="screen">SET @G = STRING(10, 20, 2);
SET @A = @G; -- @A contiendra une chaîne au hasard
SET @B = @G; -- @B contiendra une autre chaîne au hasard
PRINT @G,    -- affichera une troisième autre chaîne</pre>
<h4><a name="generator2"></a>Séquence et graine</h4>
<p>Les paramètres communs pour les générateurs de données sont <span
class="emphasis"><em>séquence</em></span> et <span
class="emphasis"><em>seed</em></span>.</p>
<p><span class="emphasis"><em>séquence</em></span> signifie qu'une séquence de
valeurs est générée en aléatoire. En d'autres termes, chaque valeur apparaît
seulement une fois avant le début de la séquence&nbsp;: ceci est utile pour les
colonnes avec une contrainte <code>UNIQUE</code>. Par exemple, ce
générateur&nbsp;:</p>
<pre class="screen">SET @G = INTEGER(10, 15, 1); -- 1 signifie la génération d'une séquence</pre>
<p>Il peut générer ce type de valeurs&nbsp;: <code class="computeroutput">14 12
10 13 11 15 14 12 10 13 11</code>... où chaque nombre apparaît une fois avant
que la séquence recommence.</p>
<p>Le paramètre <span class="emphasis"><em>séquence</em></span> doit être un
entier&nbsp;: s'il vaut 0, alors aucune séquence n'est générée (par défaut),
sinon une séquence est générée.</p>
<p><span class="emphasis"><em>graine</em></span> est une valeur entière pour
initialiser un générateur&nbsp;: deux générateurs avec les mêmes paramètres et
la même graine généreront <strong>exactement</strong> les mêmes valeurs.</p>
<p><span class="emphasis"><em>graine</em></span> doit être un entier&nbsp;:
il est utilisé directement pour initialiser le générateur aléatoire de données.</p>
<h4><a name="generator3"></a>Générateurs de données</h4>
<p>Les paramètres optionnels sont placés entre crochets.</p>
<pre class="screen">Generator
    : INTEGER ( min, max, [sequence], [seed] );
    | REAL ( min, max, precision, [sequence], [seed] );
    | DATE ( min, max, [sequence], [seed] );
    | TIME ( min, max, [sequence], [seed] );
    | DATETIME ( min, max, [sequence], [seed] );
    | STRING ( min, max, [nb], [seed] );
    | REGEX ( regex, [seed] );
    | FILE ( path, [sequence], [seed], [encoding] );
    | REFERENCE ( table, column, [sequence], [seed] );</pre>
<h5>Nombres entier</h5>
<pre class="screen">INTEGER ( min, max, [sequence], [seed] );
INTEGER ( -10, 10, 1, 123456 );</pre>
<p><code>min</code> est un entier, <code>max</code> est un entier,
<code>sequence</code> est un entier et <code>seed</code> est un entier.</p>
<h5>Nombre flottants</h5>
<pre class="screen">REAL ( min, max, precision, [sequence], [seed] );
REAL ( 1.5, 1.8, 2, 1 );</pre>
<p><code>min</code> est un nombre, <code>max</code> est un nombre,
<code>precision</code> est un entier qui indique le nombre de décimales (doit
être inférieur à 30), <code>sequence</code> est un entier et <code>seed</code>
est un entier.</p>
<h5>Dates</h5>
<pre class="screen">DATE ( min, max, [sequence], [seed] );
DATE ( '2008-05-01', '2008-05-05', 0 );</pre>
<p><code>min</code> est une chaîne représentant une date, <code>max</code> est
une chaîne représentant une date, <code>sequence</code> est un entier et
<code>seed</code> est un entier.</p>
<h5>Heures</h5>
<pre class="screen">TIME ( min, max, [sequence], [seed] );
TIME ( '00:30:00', '00:30:15', 0 );</pre>
<p><code>min</code> est une chaîne représentant une heure, <code>max</code>
est une chaîne représentant une heure, <code>sequence</code> est un entier et
<code>seed</code> est un entier.</p>
<h5>Horodatages (date/times)</h5>
<pre class="screen">DATETIME ( min, max, [sequence], [seed] );
DATETIME ( '2008-05-01 14:00:00', '2008-05-05 15:00:00', 1 );</pre>
<p><code>min</code> est une chaîne représentant un horodatage, <code>max</code>
est une chaîne représentant un horodatage, <code>sequence</code> est un entier
et <code>seed</code> est un entier.</p>
<h5>Chaînes de caractères</h5>
<pre class="screen">STRING ( min, max, [nb], [seed] );
STRING ( 10, 20, 5 );</pre>
<p><code>min</code> est un entier représentant la longueur minimale d'un mot,
<code>max</code> est un entier représentant la longueur maximale d'un mot,
<code>nb</code> est un entier représentant le nombre de mots (par défaut&nbsp;:
<code>1</code>) et <code>seed</code> est un entier.</p>
<p>Dans l'exemple ci-dessus, nous générons cinq mots (séparés avec un espace)
dont la taille est entre dix et vingt caractères.</p>
<h5>Chaînes des expressions rationnelles</h5>
<pre class="screen">REGEX ( regex, [seed] );
REGEX ( '[a-z]{1,3}@[0-9]{3}' );</pre>
<p><code>regex</code> est une chaîne représentant une expression rationnelle
simplifiée et <code>seed</code> est un entier.</p>
<p>Les expressions rationnelles simplifiées sont composées de&nbsp;:</p>
<ul type="disc">
    <li>
        <p>Ensemble de caractères autorisés comme <code>[a-z_.]</code> pour
           les caractères entre <code>a</code> et <code>z</code> +
           <code>_</code> et <code>.</code></p>
    </li>
    <li>
        <p>Caractères simples</p>
    </li>
</ul>
<p>Il est possible de spécifier la longueur minimale et maximale de l'ensemble
précédent ou de simple caractère&nbsp;:</p>
<ul type="disc">
    <li>
        <p><code>{min, max}</code> comme <code>{1,3}</code> ce qui correspond
           à la longueur entre <code>1</code> et <code>3</code></p>
    </li>
    <li>
        <p><code>{min}</code> comme <code>{3}</code> ce qui correspond
           à la longueur de <code>3</code></p>
    </li>
    <li>
        <p>Par défaut (quand rien n'est spécifié) est d'un longueur de <code>1</code></p>
    </li>
</ul>
<p>Note&nbsp;: faites attention aux espaces car <code>'a {3}'</code> signifie
un <code>a</code> suivi par trois espaces car le <code>3</code> concerne le
dernier caractère ou ensemble de caractère qu'il suit.</p>
<p>Si vous avez besoin d'utiliser <code>[</code> <code>]</code> <code>\</code>
<code>{</code> ou <code>}</code>, ils doivent être échappés car ce sont des
caractères spéciaux. Rappelez-vous d'utiliser un <strong>double
antislash</strong>&nbsp;: <code>'\\[{3}'</code> pour trois <code>[</code>.</p>
<h5>Chaînes de fichiers dictionnaires</h5>
<pre class="screen">FILE ( path, [sequence], [seed], [encoding] );
FILE ( 'file.txt', 0, 54321, 'utf-8' );</pre>
<p><code>path</code> est une chaîne représentant le chemin d'un fichier texte,
<code>sequence</code> est un entier, <code>seed</code> est un entier et
<code>encoding</code> est une chaîne représentant le jeu de caractères du fichier
(par défaut, il s'agit de l'encodage du système).</p>
<p>Ceci génère un entier aléatoire entre 1 et le nombre de lignes du fichier,
puis renvoie cette ligne. Si le fichier n'existe pas, une exception est
levée.</p>
<p><code>encoding</code> supporte les encodages les plus connus comme utf-8,
utf-16le, utf-16be, iso-8859-1, ...</p>
<h5>Référence à un autre champ</h5>
<pre class="screen">REFERENCE ( table, column, [sequence], [seed] );
REFERENCE ( 'tab', 'col', 1 );</pre>
<p><code>table</code> est une chaîne représentant une table, <code>column</code>
est une chaîne représentant une colonne de la table, <code>sequence</code> est
un entier et <code>seed</code> est un entier.</p>
<p>Ceci est utile pour générer des données à placer dans les colonnes contraintes
avec une clé étrangère.</p>
</body>
</html>
